{
  "version": 3,
  "sources": ["../react/node_modules/classnames/index.js", "../react/src/const/common.ts", "../react/src/services/loraService.ts", "../react/node_modules/preact/src/constants.js", "../react/node_modules/preact/src/util.js", "../react/node_modules/preact/src/options.js", "../react/node_modules/preact/src/create-element.js", "../react/node_modules/preact/src/component.js", "../react/node_modules/preact/src/diff/props.js", "../react/node_modules/preact/src/create-context.js", "../react/node_modules/preact/src/diff/children.js", "../react/node_modules/preact/src/diff/index.js", "../react/node_modules/preact/src/render.js", "../react/node_modules/preact/src/clone-element.js", "../react/node_modules/preact/src/diff/catch-error.js", "../react/node_modules/preact/hooks/src/index.js", "../react/src/reducers/dispatchHelper.ts", "../react/src/components/ui/PreviewSection.tsx", "../react/src/components/ui/ListSection.tsx", "../react/src/utils/commonUtil.ts", "../react/src/services/tagService.ts", "../react/src/utils/editorUtil.ts", "../react/src/utils/externalUtil.ts", "../react/src/components/ui/TabsSection.tsx", "../react/src/utils/uiUtil.ts", "../react/src/helpers/styleHelper.ts", "../react/src/parsers/promptParser.ts", "../react/src/hooks/useTextareaEvents.ts", "../react/src/services/suggestionService.ts", "../react/src/hooks/usePromptContext.ts", "../react/src/hooks/useTextareaHandlers.ts", "../react/node_modules/fflate/esm/browser.js", "../react/src/services/initializationService.ts", "../react/src/hooks/useInitialization.ts", "../react/src/components/ui/AppComponent.tsx", "../react/src/reducers/appReducer.ts", "../react/src/components/core/App.tsx", "../react/src/index.ts"],
  "sourcesContent": ["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n", "export const EXTENSION_ID: string = 'prompt_pilot';\nexport const API_PREFIX: string = `/${EXTENSION_ID}/v1`;\n\nexport const TEXTAREA_SELECTOR = \"*:is([id*='_toprow'] [id*='_prompt'], .prompt) textarea\";\n\nexport const DEBOUNCE_DELAY = 200;\n", "import { ItemProps } from '@/types/props';\nimport { EXTENSION_ID } from '@/const/common';\nimport { ResponseData } from '@/types/api';\nimport { LoraModel } from '@/types/model';\n\nlet loraModels: LoraModel[];\n\nexport function initializeLoraModels(resData: ResponseData | undefined): void {\n    if (!resData) {\n        return;\n    }\n    loraModels = [];\n    Object.entries(resData.loraModels).forEach(([lora_name, data]) => {\n        loraModels.push({\n            value: lora_name,\n            searchWords: data.search_words,\n            previewFile: data.preview_file,\n        });\n    });\n}\n\nexport function searchLora(query: string): ItemProps[] {\n    const queries = query\n        .toLowerCase()\n        .split(/[ _-]/g)\n        .filter((q) => q.trim() !== '');\n\n    let resultSet: ItemProps[] = [];\n    loraModels.forEach((lora) => {\n        const matchWordSet = new Set<string>();\n        for (const word of lora.searchWords) {\n            const flatWord = word.replace(/[ _-]/g, '');\n            queries.forEach((q) => {\n                if (flatWord.includes(q)) {\n                    matchWordSet.add(q);\n                }\n            });\n        }\n        if (queries.length === matchWordSet.size) {\n            const props: ItemProps = {\n                ...lora,\n                matchedWords: [...matchWordSet].map((w) => ({ index: 0, word: w })),\n                view: null,\n                isPriority: false,\n                category: '',\n                useCount: 0,\n                postCount: 0,\n                consequentTagModel: null,\n                isOfficial: false,\n            };\n            resultSet.push(props);\n        }\n    });\n    resultSet = resultSet.sort((a, b) => compare(a, b, query, queries));\n    let groupCounter = window.opts[`${EXTENSION_ID}_max_results_grouplora`] as number;\n    return resultSet.filter(() => {\n        if (groupCounter > 0) {\n            groupCounter -= 1;\n            return true;\n        }\n        return false;\n    });\n}\n\nfunction compare(self: ItemProps, other: ItemProps, query: string, queries: string[]): number {\n    if (self.value === query) return -1;\n    if (other.value === query) return 1;\n\n    if (other.matchedWords.length !== self.matchedWords.length) {\n        return other.matchedWords.length - self.matchedWords.length;\n    }\n\n    const thisStartsQuery = matchStarts(self, queries);\n    const otherStartsQuery = matchStarts(other, queries);\n    if (thisStartsQuery && !otherStartsQuery) return -1;\n    if (!thisStartsQuery && otherStartsQuery) return 1;\n\n    return self.value < other.value ? -1 : 1;\n}\n\nfunction matchStarts(obj: ItemProps, queries: string[]): boolean {\n    for (const q of queries) {\n        for (const title of obj.value.split(/[ _-]/g)) {\n            if (title.startsWith(q)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n", "/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Indicates that this node needs to be inserted while patching children */\nexport const INSERT_VNODE = 1 << 2;\n/** Indicates a VNode has been matched with another VNode in the diff */\nexport const MATCHED = 1 << 1;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(MODE_HYDRATE | MODE_SUSPENDED);\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const XHTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\nexport const MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n\nexport const NULL = null;\nexport const UNDEFINED = undefined;\nexport const EMPTY_OBJ = /** @type {any} */ ({});\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL =\n\t/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n", "import { EMPTY_ARR } from './constants';\n\nexport const isArray = Array.isArray;\n\n/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\t// @ts-expect-error We change the type of `obj` to be `O & P`\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {import('./index').ContainerNode} node The node to remove\n */\nexport function removeNode(node) {\n\tif (node && node.parentNode) node.parentNode.removeChild(node);\n}\n\nexport const slice = EMPTY_ARR.slice;\n", "import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n", "import { slice } from './util';\nimport options from './options';\nimport { NULL, UNDEFINED } from './constants';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor for this\n * virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the\n * virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != NULL) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] == UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, NULL);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\t/** @type {import('./internal').VNode} */\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: NULL,\n\t\t_parent: NULL,\n\t\t_depth: 0,\n\t\t_dom: NULL,\n\t\t_component: NULL,\n\t\tconstructor: UNDEFINED,\n\t\t_original: original == NULL ? ++vnodeId : original,\n\t\t_index: -1,\n\t\t_flags: 0\n\t};\n\n\t// Only invoke the vnode hook if this was *not* a direct copy:\n\tif (original == NULL && options.vnode != NULL) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: NULL };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != NULL && vnode.constructor == UNDEFINED;\n", "import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\nimport { MODE_HYDRATE, NULL } from './constants';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function BaseComponent(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nBaseComponent.prototype.setState = function (update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != NULL && this._nextState != this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == NULL) return;\n\n\tif (this._vnode) {\n\t\tif (callback) {\n\t\t\tthis._stateCallbacks.push(callback);\n\t\t}\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nBaseComponent.prototype.forceUpdate = function (callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](https://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {ComponentChildren | void}\n */\nBaseComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == NULL) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._index + 1)\n\t\t\t: NULL;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != NULL && sibling._dom != NULL) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : NULL;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet oldVNode = component._vnode,\n\t\toldDom = oldVNode._dom,\n\t\tcommitQueue = [],\n\t\trefQueue = [];\n\n\tif (component._parentDom) {\n\t\tconst newVNode = assign({}, oldVNode);\n\t\tnewVNode._original = oldVNode._original + 1;\n\t\tif (options.vnode) options.vnode(newVNode);\n\n\t\tdiff(\n\t\t\tcomponent._parentDom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tcomponent._parentDom.namespaceURI,\n\t\t\toldVNode._flags & MODE_HYDRATE ? [oldDom] : NULL,\n\t\t\tcommitQueue,\n\t\t\toldDom == NULL ? getDomSibling(oldVNode) : oldDom,\n\t\t\t!!(oldVNode._flags & MODE_HYDRATE),\n\t\t\trefQueue\n\t\t);\n\n\t\tnewVNode._original = oldVNode._original;\n\t\tnewVNode._parent._children[newVNode._index] = newVNode;\n\t\tcommitRoot(commitQueue, newVNode, refQueue);\n\n\t\tif (newVNode._dom != oldDom) {\n\t\t\tupdateParentDomPointers(newVNode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != NULL && vnode._component != NULL) {\n\t\tvnode._dom = vnode._component.base = NULL;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != NULL && child._dom != NULL) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce != options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/**\n * @param {import('./internal').Component} a\n * @param {import('./internal').Component} b\n */\nconst depthSort = (a, b) => a._vnode._depth - b._vnode._depth;\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet c,\n\t\tl = 1;\n\n\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t// process() calls from getting scheduled while `queue` is still being consumed.\n\twhile (rerenderQueue.length) {\n\t\t// Keep the rerender queue sorted by (depth, insertion order). The queue\n\t\t// will initially be sorted on the first iteration only if it has more than 1 item.\n\t\t//\n\t\t// New items can be added to the queue e.g. when rerendering a provider, so we want to\n\t\t// keep the order from top to bottom with those new items so we can handle them in a\n\t\t// single pass\n\t\tif (rerenderQueue.length > l) {\n\t\t\trerenderQueue.sort(depthSort);\n\t\t}\n\n\t\tc = rerenderQueue.shift();\n\t\tl = rerenderQueue.length;\n\n\t\tif (c._dirty) {\n\t\t\trenderComponent(c);\n\t\t}\n\t}\n\tprocess._rerenderCount = 0;\n}\n\nprocess._rerenderCount = 0;\n", "import { IS_NON_DIMENSIONAL, NULL, SVG_NAMESPACE } from '../constants';\nimport options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] == '-') {\n\t\tstyle.setProperty(key, value == NULL ? '' : value);\n\t} else if (value == NULL) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\nconst CAPTURE_REGEX = /(PointerCapture)$|Capture$/i;\n\n// A logical clock to solve issues like https://github.com/preactjs/preact/issues/3927.\n// When the DOM performs an event it leaves micro-ticks in between bubbling up which means that\n// an event can trigger on a newly reated DOM-node while the event bubbles up.\n//\n// Originally inspired by Vue\n// (https://github.com/vuejs/core/blob/caeb8a68811a1b0f79/packages/runtime-dom/src/modules/events.ts#L90-L101),\n// but modified to use a logical clock instead of Date.now() in case event handlers get attached\n// and events get dispatched during the same millisecond.\n//\n// The clock is incremented after each new event dispatch. This allows 1 000 000 new events\n// per second for over 280 years before the value reaches Number.MAX_SAFE_INTEGER (2**53 - 1).\nlet eventClock = 0;\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {string} namespace Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, namespace) {\n\tlet useCapture;\n\n\to: if (name == 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] != oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] == 'o' && name[1] == 'n') {\n\t\tuseCapture = name != (name = name.replace(CAPTURE_REGEX, '$1'));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (\n\t\t\tname.toLowerCase() in dom ||\n\t\t\tname == 'onFocusOut' ||\n\t\t\tname == 'onFocusIn'\n\t\t)\n\t\t\tname = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tvalue._attached = eventClock;\n\t\t\t\tdom.addEventListener(\n\t\t\t\t\tname,\n\t\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\t\tuseCapture\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tvalue._attached = oldValue._attached;\n\t\t\t}\n\t\t} else {\n\t\t\tdom.removeEventListener(\n\t\t\t\tname,\n\t\t\t\tuseCapture ? eventProxyCapture : eventProxy,\n\t\t\t\tuseCapture\n\t\t\t);\n\t\t}\n\t} else {\n\t\tif (namespace == SVG_NAMESPACE) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink(H|:h)/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname != 'width' &&\n\t\t\tname != 'height' &&\n\t\t\tname != 'href' &&\n\t\t\tname != 'list' &&\n\t\t\tname != 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname != 'tabIndex' &&\n\t\t\tname != 'download' &&\n\t\t\tname != 'rowSpan' &&\n\t\t\tname != 'colSpan' &&\n\t\t\tname != 'role' &&\n\t\t\tname != 'popover' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == NULL ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// aria- and data- attributes have no boolean representation.\n\t\t// A `false` value is different from the attribute not being\n\t\t// present, so we can't remove it. For non-boolean aria\n\t\t// attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost too many bytes. On top of\n\t\t// that other frameworks generally stringify `false`.\n\n\t\tif (typeof value == 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (value != NULL && (value !== false || name[4] == '-')) {\n\t\t\tdom.setAttribute(name, name == 'popover' && value == true ? '' : value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Create an event proxy function.\n * @param {boolean} useCapture Is the event handler for the capture phase.\n * @private\n */\nfunction createEventProxy(useCapture) {\n\t/**\n\t * Proxy an event to hooked event handlers\n\t * @param {import('../internal').PreactEvent} e The event object from the browser\n\t * @private\n\t */\n\treturn function (e) {\n\t\tif (this._listeners) {\n\t\t\tconst eventHandler = this._listeners[e.type + useCapture];\n\t\t\tif (e._dispatched == NULL) {\n\t\t\t\te._dispatched = eventClock++;\n\n\t\t\t\t// When `e._dispatched` is smaller than the time when the targeted event\n\t\t\t\t// handler was attached we know we have bubbled up to an element that was added\n\t\t\t\t// during patching the DOM.\n\t\t\t} else if (e._dispatched < eventHandler._attached) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn eventHandler(options.event ? options.event(e) : e);\n\t\t}\n\t};\n}\n\nconst eventProxy = createEventProxy(false);\nconst eventProxyCapture = createEventProxy(true);\n", "import { enqueueRender } from './component';\nimport { NULL } from './constants';\n\nexport let i = 0;\n\nexport function createContext(defaultValue) {\n\tfunction Context(props) {\n\t\tif (!this.getChildContext) {\n\t\t\t/** @type {Set<import('./internal').Component> | null} */\n\t\t\tlet subs = new Set();\n\t\t\tlet ctx = {};\n\t\t\tctx[Context._id] = this;\n\n\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tsubs = NULL;\n\t\t\t};\n\n\t\t\tthis.shouldComponentUpdate = function (_props) {\n\t\t\t\t// @ts-expect-error even\n\t\t\t\tif (this.props.value != _props.value) {\n\t\t\t\t\tsubs.forEach(c => {\n\t\t\t\t\t\tc._force = true;\n\t\t\t\t\t\tenqueueRender(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.sub = c => {\n\t\t\t\tsubs.add(c);\n\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\tif (subs) {\n\t\t\t\t\t\tsubs.delete(c);\n\t\t\t\t\t}\n\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\treturn props.children;\n\t}\n\n\tContext._id = '__cC' + i++;\n\tContext._defaultValue = defaultValue;\n\n\t/** @type {import('./internal').FunctionComponent} */\n\tContext.Consumer = (props, contextValue) => {\n\t\treturn props.children(contextValue);\n\t};\n\n\t// we could also get rid of _contextRef entirely\n\tContext.Provider =\n\t\tContext._contextRef =\n\t\tContext.Consumer.contextType =\n\t\t\tContext;\n\n\treturn Context;\n}\n", "import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport {\n\tEMPTY_OBJ,\n\tEMPTY_ARR,\n\tINSERT_VNODE,\n\tMATCHED,\n\tUNDEFINED,\n\tNULL\n} from '../constants';\nimport { isArray } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * Diff the children of a virtual node\n * @param {PreactElement} parentDom The DOM element whose children are being\n * diffed\n * @param {ComponentChildren[]} renderResult\n * @param {VNode} newParentVNode The new virtual node whose children should be\n * diff'ed against oldParentVNode\n * @param {VNode} oldParentVNode The old virtual node whose children should be\n * diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\tlet i,\n\t\t/** @type {VNode} */\n\t\toldVNode,\n\t\t/** @type {VNode} */\n\t\tchildVNode,\n\t\t/** @type {PreactElement} */\n\t\tnewDom,\n\t\t/** @type {PreactElement} */\n\t\tfirstChildDom;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\t/** @type {VNode[]} */\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet newChildrenLength = renderResult.length;\n\n\toldDom = constructNewChildrenArray(\n\t\tnewParentVNode,\n\t\trenderResult,\n\t\toldChildren,\n\t\toldDom,\n\t\tnewChildrenLength\n\t);\n\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\tchildVNode = newParentVNode._children[i];\n\t\tif (childVNode == NULL) continue;\n\n\t\t// At this point, constructNewChildrenArray has assigned _index to be the\n\t\t// matchingIndex for this VNode's oldVNode (or -1 if there is no oldVNode).\n\t\tif (childVNode._index == -1) {\n\t\t\toldVNode = EMPTY_OBJ;\n\t\t} else {\n\t\t\toldVNode = oldChildren[childVNode._index] || EMPTY_OBJ;\n\t\t}\n\n\t\t// Update childVNode._index to its final index\n\t\tchildVNode._index = i;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tlet result = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\n\t\t// Adjust DOM nodes\n\t\tnewDom = childVNode._dom;\n\t\tif (childVNode.ref && oldVNode.ref != childVNode.ref) {\n\t\t\tif (oldVNode.ref) {\n\t\t\t\tapplyRef(oldVNode.ref, NULL, childVNode);\n\t\t\t}\n\t\t\trefQueue.push(\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildVNode._component || newDom,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t}\n\n\t\tif (firstChildDom == NULL && newDom != NULL) {\n\t\t\tfirstChildDom = newDom;\n\t\t}\n\n\t\tif (\n\t\t\tchildVNode._flags & INSERT_VNODE ||\n\t\t\toldVNode._children === childVNode._children\n\t\t) {\n\t\t\toldDom = insert(childVNode, oldDom, parentDom);\n\t\t} else if (typeof childVNode.type == 'function' && result !== UNDEFINED) {\n\t\t\toldDom = result;\n\t\t} else if (newDom) {\n\t\t\toldDom = newDom.nextSibling;\n\t\t}\n\n\t\t// Unset diffing flags\n\t\tchildVNode._flags &= ~(INSERT_VNODE | MATCHED);\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} newParentVNode\n * @param {ComponentChildren[]} renderResult\n * @param {VNode[]} oldChildren\n */\nfunction constructNewChildrenArray(\n\tnewParentVNode,\n\trenderResult,\n\toldChildren,\n\toldDom,\n\tnewChildrenLength\n) {\n\t/** @type {number} */\n\tlet i;\n\t/** @type {VNode} */\n\tlet childVNode;\n\t/** @type {VNode} */\n\tlet oldVNode;\n\n\tlet oldChildrenLength = oldChildren.length,\n\t\tremainingOldChildren = oldChildrenLength;\n\n\tlet skew = 0;\n\n\tnewParentVNode._children = new Array(newChildrenLength);\n\tfor (i = 0; i < newChildrenLength; i++) {\n\t\t// @ts-expect-error We are reusing the childVNode variable to hold both the\n\t\t// pre and post normalized childVNode\n\t\tchildVNode = renderResult[i];\n\n\t\tif (\n\t\t\tchildVNode == NULL ||\n\t\t\ttypeof childVNode == 'boolean' ||\n\t\t\ttypeof childVNode == 'function'\n\t\t) {\n\t\t\tnewParentVNode._children[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (\n\t\t\ttypeof childVNode == 'string' ||\n\t\t\ttypeof childVNode == 'number' ||\n\t\t\t// eslint-disable-next-line valid-typeof\n\t\t\ttypeof childVNode == 'bigint' ||\n\t\t\tchildVNode.constructor == String\n\t\t) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tNULL,\n\t\t\t\tchildVNode,\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tNULL,\n\t\t\t\tNULL,\n\t\t\t\tNULL\n\t\t\t);\n\t\t} else if (childVNode.constructor == UNDEFINED && childVNode._depth > 0) {\n\t\t\t// VNode is already in use, clone it. This can happen in the following\n\t\t\t// scenario:\n\t\t\t//   const reuse = <div />\n\t\t\t//   <div>{reuse}<span />{reuse}</div>\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tchildVNode.ref ? childVNode.ref : NULL,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\tconst skewedIndex = i + skew;\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Temporarily store the matchingIndex on the _index property so we can pull\n\t\t// out the oldVNode in diffChildren. We'll override this to the VNode's\n\t\t// final index after using this property to get the oldVNode\n\t\tconst matchingIndex = (childVNode._index = findMatchingIndex(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\tskewedIndex,\n\t\t\tremainingOldChildren\n\t\t));\n\n\t\toldVNode = NULL;\n\t\tif (matchingIndex != -1) {\n\t\t\toldVNode = oldChildren[matchingIndex];\n\t\t\tremainingOldChildren--;\n\t\t\tif (oldVNode) {\n\t\t\t\toldVNode._flags |= MATCHED;\n\t\t\t}\n\t\t}\n\n\t\t// Here, we define isMounting for the purposes of the skew diffing\n\t\t// algorithm. Nodes that are unsuspending are considered mounting and we detect\n\t\t// this by checking if oldVNode._original == null\n\t\tconst isMounting = oldVNode == NULL || oldVNode._original == NULL;\n\n\t\tif (isMounting) {\n\t\t\tif (matchingIndex == -1) {\n\t\t\t\t// When the array of children is growing we need to decrease the skew\n\t\t\t\t// as we are adding a new element to the array.\n\t\t\t\t// Example:\n\t\t\t\t// [1, 2, 3] --> [0, 1, 2, 3]\n\t\t\t\t// oldChildren   newChildren\n\t\t\t\t//\n\t\t\t\t// The new element is at index 0, so our skew is 0,\n\t\t\t\t// we need to decrease the skew as we are adding a new element.\n\t\t\t\t// The decrease will cause us to compare the element at position 1\n\t\t\t\t// with value 1 with the element at position 0 with value 0.\n\t\t\t\t//\n\t\t\t\t// A linear concept is applied when the array is shrinking,\n\t\t\t\t// if the length is unchanged we can assume that no skew\n\t\t\t\t// changes are needed.\n\t\t\t\tif (newChildrenLength > oldChildrenLength) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else if (newChildrenLength < oldChildrenLength) {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we are mounting a DOM VNode, mark it for insertion\n\t\t\tif (typeof childVNode.type != 'function') {\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t} else if (matchingIndex != skewedIndex) {\n\t\t\t// When we move elements around i.e. [0, 1, 2] --> [1, 0, 2]\n\t\t\t// --> we diff 1, we find it at position 1 while our skewed index is 0 and our skew is 0\n\t\t\t//     we set the skew to 1 as we found an offset.\n\t\t\t// --> we diff 0, we find it at position 0 while our skewed index is at 2 and our skew is 1\n\t\t\t//     this makes us increase the skew again.\n\t\t\t// --> we diff 2, we find it at position 2 while our skewed index is at 4 and our skew is 2\n\t\t\t//\n\t\t\t// this becomes an optimization question where currently we see a 1 element offset as an insertion\n\t\t\t// or deletion i.e. we optimize for [0, 1, 2] --> [9, 0, 1, 2]\n\t\t\t// while a more than 1 offset we see as a swap.\n\t\t\t// We could probably build heuristics for having an optimized course of action here as well, but\n\t\t\t// might go at the cost of some bytes.\n\t\t\t//\n\t\t\t// If we wanted to optimize for i.e. only swaps we'd just do the last two code-branches and have\n\t\t\t// only the first item be a re-scouting and all the others fall in their skewed counter-part.\n\t\t\t// We could also further optimize for swaps\n\t\t\tif (matchingIndex == skewedIndex - 1) {\n\t\t\t\tskew--;\n\t\t\t} else if (matchingIndex == skewedIndex + 1) {\n\t\t\t\tskew++;\n\t\t\t} else {\n\t\t\t\tif (matchingIndex > skewedIndex) {\n\t\t\t\t\tskew--;\n\t\t\t\t} else {\n\t\t\t\t\tskew++;\n\t\t\t\t}\n\n\t\t\t\t// Move this VNode's DOM if the original index (matchingIndex) doesn't\n\t\t\t\t// match the new skew index (i + new skew)\n\t\t\t\t// In the former two branches we know that it matches after skewing\n\t\t\t\tchildVNode._flags |= INSERT_VNODE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any. Loop forwards so that as we\n\t// unmount DOM from the beginning of the oldChildren, we can adjust oldDom to\n\t// point to the next child, which needs to be the first DOM node that won't be\n\t// unmounted.\n\tif (remainingOldChildren) {\n\t\tfor (i = 0; i < oldChildrenLength; i++) {\n\t\t\toldVNode = oldChildren[i];\n\t\t\tif (oldVNode != NULL && (oldVNode._flags & MATCHED) == 0) {\n\t\t\t\tif (oldVNode._dom == oldDom) {\n\t\t\t\t\toldDom = getDomSibling(oldVNode);\n\t\t\t\t}\n\n\t\t\t\tunmount(oldVNode, oldVNode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn oldDom;\n}\n\n/**\n * @param {VNode} parentVNode\n * @param {PreactElement} oldDom\n * @param {PreactElement} parentDom\n * @returns {PreactElement}\n */\nfunction insert(parentVNode, oldDom, parentDom) {\n\t// Note: VNodes in nested suspended trees may be missing _children.\n\n\tif (typeof parentVNode.type == 'function') {\n\t\tlet children = parentVNode._children;\n\t\tfor (let i = 0; children && i < children.length; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\t// If we enter this code path on sCU bailout, where we copy\n\t\t\t\t// oldVNode._children to newVNode._children, we need to update the old\n\t\t\t\t// children's _parent pointer to point to the newVNode (parentVNode\n\t\t\t\t// here).\n\t\t\t\tchildren[i]._parent = parentVNode;\n\t\t\t\toldDom = insert(children[i], oldDom, parentDom);\n\t\t\t}\n\t\t}\n\n\t\treturn oldDom;\n\t} else if (parentVNode._dom != oldDom) {\n\t\tif (oldDom && parentVNode.type && !parentDom.contains(oldDom)) {\n\t\t\toldDom = getDomSibling(parentVNode);\n\t\t}\n\t\tparentDom.insertBefore(parentVNode._dom, oldDom || NULL);\n\t\toldDom = parentVNode._dom;\n\t}\n\n\tdo {\n\t\toldDom = oldDom && oldDom.nextSibling;\n\t} while (oldDom != NULL && oldDom.nodeType == 8);\n\n\treturn oldDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {ComponentChildren} children The unflattened children of a virtual\n * node\n * @returns {VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == NULL || typeof children == 'boolean') {\n\t} else if (isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\n/**\n * @param {VNode} childVNode\n * @param {VNode[]} oldChildren\n * @param {number} skewedIndex\n * @param {number} remainingOldChildren\n * @returns {number}\n */\nfunction findMatchingIndex(\n\tchildVNode,\n\toldChildren,\n\tskewedIndex,\n\tremainingOldChildren\n) {\n\tconst key = childVNode.key;\n\tconst type = childVNode.type;\n\tlet oldVNode = oldChildren[skewedIndex];\n\n\t// We only need to perform a search if there are more children\n\t// (remainingOldChildren) to search. However, if the oldVNode we just looked\n\t// at skewedIndex was not already used in this diff, then there must be at\n\t// least 1 other (so greater than 1) remainingOldChildren to attempt to match\n\t// against. So the following condition checks that ensuring\n\t// remainingOldChildren > 1 if the oldVNode is not already used/matched. Else\n\t// if the oldVNode was null or matched, then there could needs to be at least\n\t// 1 (aka `remainingOldChildren > 0`) children to find and compare against.\n\t//\n\t// If there is an unkeyed functional VNode, that isn't a built-in like our Fragment,\n\t// we should not search as we risk re-using state of an unrelated VNode. (reverted for now)\n\tlet shouldSearch =\n\t\t// (typeof type != 'function' || type === Fragment || key) &&\n\t\tremainingOldChildren >\n\t\t(oldVNode != NULL && (oldVNode._flags & MATCHED) == 0 ? 1 : 0);\n\n\tif (\n\t\t(oldVNode === NULL && childVNode.key == null) ||\n\t\t(oldVNode &&\n\t\t\tkey == oldVNode.key &&\n\t\t\ttype == oldVNode.type &&\n\t\t\t(oldVNode._flags & MATCHED) == 0)\n\t) {\n\t\treturn skewedIndex;\n\t} else if (shouldSearch) {\n\t\tlet x = skewedIndex - 1;\n\t\tlet y = skewedIndex + 1;\n\t\twhile (x >= 0 || y < oldChildren.length) {\n\t\t\tif (x >= 0) {\n\t\t\t\toldVNode = oldChildren[x];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype == oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\tx--;\n\t\t\t}\n\n\t\t\tif (y < oldChildren.length) {\n\t\t\t\toldVNode = oldChildren[y];\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\t(oldVNode._flags & MATCHED) == 0 &&\n\t\t\t\t\tkey == oldVNode.key &&\n\t\t\t\t\ttype == oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\treturn y;\n\t\t\t\t}\n\t\t\t\ty++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n", "import {\n\tEMPTY_OBJ,\n\tMATH_NAMESPACE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tNULL,\n\tRESET_MODE,\n\tSVG_NAMESPACE,\n\tUNDEFINED,\n\tXHTML_NAMESPACE\n} from '../constants';\nimport { BaseComponent, getDomSibling } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren } from './children';\nimport { setProperty } from './props';\nimport { assign, isArray, removeNode, slice } from '../util';\nimport options from '../options';\n\n/**\n * @typedef {import('../internal').ComponentChildren} ComponentChildren\n * @typedef {import('../internal').Component} Component\n * @typedef {import('../internal').PreactElement} PreactElement\n * @typedef {import('../internal').VNode} VNode\n */\n\n/**\n * @template {any} T\n * @typedef {import('../internal').Ref<T>} Ref<T>\n */\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {PreactElement} parentDom The parent of the DOM element\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by\n * getChildContext\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {PreactElement} oldDom The current attached DOM element any new dom\n * elements should be placed around. Likely `null` on first render (except when\n * hydrating). Can be a sibling DOM element when diffing Fragments that have\n * siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating,\n\trefQueue\n) {\n\t/** @type {any} */\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor != UNDEFINED) return NULL;\n\n\t// If the previous diff bailed out, resume creating/hydrating.\n\tif (oldVNode._flags & MODE_SUSPENDED) {\n\t\tisHydrating = !!(oldVNode._flags & MODE_HYDRATE);\n\t\toldDom = newVNode._dom = oldVNode._dom;\n\t\texcessDomChildren = [oldDom];\n\t}\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\touter: if (typeof newType == 'function') {\n\t\ttry {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\t\t\tconst isClassComponent =\n\t\t\t\t'prototype' in newType && newType.prototype.render;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif (isClassComponent) {\n\t\t\t\t\t// @ts-expect-error The check above verifies that newType is suppose to be constructed\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error Trust me, Component implements the interface we want\n\t\t\t\t\tnewVNode._component = c = new BaseComponent(\n\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (isClassComponent && c._nextState == NULL) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\n\t\t\tif (isClassComponent && newType.getDerivedStateFromProps != NULL) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\t\t\tc._vnode = newVNode;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tc.componentWillMount != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidMount != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tisClassComponent &&\n\t\t\t\t\tnewType.getDerivedStateFromProps == NULL &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != NULL\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != NULL &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original == oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original != oldVNode._original) {\n\t\t\t\t\t\t// When we are dealing with a bail because of sCU we have to update\n\t\t\t\t\t\t// the props, state and dirty-state.\n\t\t\t\t\t\t// when we are dealing with strict-equality we don't as the child could still\n\t\t\t\t\t\t// be dirtied see #3883\n\t\t\t\t\t\tc.props = newProps;\n\t\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t\tc._dirty = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tnewVNode._children.some(vnode => {\n\t\t\t\t\t\tif (vnode) vnode._parent = newVNode;\n\t\t\t\t\t});\n\n\t\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t\t}\n\t\t\t\t\tc._stateCallbacks = [];\n\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != NULL) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (isClassComponent && c.componentDidUpdate != NULL) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc._parentDom = parentDom;\n\t\t\tc._force = false;\n\n\t\t\tlet renderHook = options._render,\n\t\t\t\tcount = 0;\n\t\t\tif (isClassComponent) {\n\t\t\t\tc.state = c._nextState;\n\t\t\t\tc._dirty = false;\n\n\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\tfor (let i = 0; i < c._stateCallbacks.length; i++) {\n\t\t\t\t\tc._renderCallbacks.push(c._stateCallbacks[i]);\n\t\t\t\t}\n\t\t\t\tc._stateCallbacks = [];\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tc._dirty = false;\n\t\t\t\t\tif (renderHook) renderHook(newVNode);\n\n\t\t\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t\t\t// Handle setState called in render, see #2553\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t} while (c._dirty && ++count < 25);\n\t\t\t}\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != NULL) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (isClassComponent && !isNew && c.getSnapshotBeforeUpdate != NULL) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != NULL && tmp.type === Fragment && tmp.key == NULL;\n\t\t\tlet renderResult = tmp;\n\n\t\t\tif (isTopLevelFragment) {\n\t\t\t\trenderResult = cloneNode(tmp.props.children);\n\t\t\t}\n\n\t\t\toldDom = diffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tisArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnamespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\t\tnewVNode._flags &= RESET_MODE;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = NULL;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnewVNode._original = NULL;\n\t\t\t// if hydrating or creating initial tree, bailout preserves DOM:\n\t\t\tif (isHydrating || excessDomChildren != NULL) {\n\t\t\t\tif (e.then) {\n\t\t\t\t\tnewVNode._flags |= isHydrating\n\t\t\t\t\t\t? MODE_HYDRATE | MODE_SUSPENDED\n\t\t\t\t\t\t: MODE_SUSPENDED;\n\n\t\t\t\t\twhile (oldDom && oldDom.nodeType == 8 && oldDom.nextSibling) {\n\t\t\t\t\t\toldDom = oldDom.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\texcessDomChildren[excessDomChildren.indexOf(oldDom)] = NULL;\n\t\t\t\t\tnewVNode._dom = oldDom;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = excessDomChildren.length; i--; ) {\n\t\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t}\n\t\t\toptions._catchError(e, newVNode, oldVNode);\n\t\t}\n\t} else if (\n\t\texcessDomChildren == NULL &&\n\t\tnewVNode._original == oldVNode._original\n\t) {\n\t\tnewVNode._children = oldVNode._children;\n\t\tnewVNode._dom = oldVNode._dom;\n\t} else {\n\t\toldDom = newVNode._dom = diffElementNodes(\n\t\t\toldVNode._dom,\n\t\t\tnewVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tnamespace,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\tisHydrating,\n\t\t\trefQueue\n\t\t);\n\t}\n\n\tif ((tmp = options.diffed)) tmp(newVNode);\n\n\treturn newVNode._flags & MODE_SUSPENDED ? undefined : oldDom;\n}\n\n/**\n * @param {Array<Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {VNode} root\n */\nexport function commitRoot(commitQueue, root, refQueue) {\n\tfor (let i = 0; i < refQueue.length; i++) {\n\t\tapplyRef(refQueue[i], refQueue[++i], refQueue[++i]);\n\t}\n\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\t// @ts-expect-error Reuse the commitQueue variable here so the type changes\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\t// @ts-expect-error See above comment on commitQueue\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\nfunction cloneNode(node) {\n\tif (\n\t\ttypeof node != 'object' ||\n\t\tnode == NULL ||\n\t\t(node._depth && node._depth > 0)\n\t) {\n\t\treturn node;\n\t}\n\n\tif (isArray(node)) {\n\t\treturn node.map(cloneNode);\n\t}\n\n\treturn assign({}, node);\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {PreactElement} dom The DOM element representing the virtual nodes\n * being diffed\n * @param {VNode} newVNode The new virtual node\n * @param {VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {string} namespace Current namespace of the DOM node (HTML, SVG, or MathML)\n * @param {Array<PreactElement>} excessDomChildren\n * @param {Array<Component>} commitQueue List of components which have callbacks\n * to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @param {any[]} refQueue an array of elements needed to invoke refs\n * @returns {PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tnamespace,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating,\n\trefQueue\n) {\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\tlet nodeType = /** @type {string} */ (newVNode.type);\n\t/** @type {any} */\n\tlet i;\n\t/** @type {{ __html?: string }} */\n\tlet newHtml;\n\t/** @type {{ __html?: string }} */\n\tlet oldHtml;\n\t/** @type {ComponentChildren} */\n\tlet newChildren;\n\tlet value;\n\tlet inputValue;\n\tlet checked;\n\n\t// Tracks entering and exiting namespaces when descending through the tree.\n\tif (nodeType == 'svg') namespace = SVG_NAMESPACE;\n\telse if (nodeType == 'math') namespace = MATH_NAMESPACE;\n\telse if (!namespace) namespace = XHTML_NAMESPACE;\n\n\tif (excessDomChildren != NULL) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tvalue = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tvalue &&\n\t\t\t\t'setAttribute' in value == !!nodeType &&\n\t\t\t\t(nodeType ? value.localName == nodeType : value.nodeType == 3)\n\t\t\t) {\n\t\t\t\tdom = value;\n\t\t\t\texcessDomChildren[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == NULL) {\n\t\tif (nodeType == NULL) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = document.createElementNS(\n\t\t\tnamespace,\n\t\t\tnodeType,\n\t\t\tnewProps.is && newProps\n\t\t);\n\n\t\t// we are creating a new node, so we can assume this is a new subtree (in\n\t\t// case we are hydrating), this deopts the hydrate\n\t\tif (isHydrating) {\n\t\t\tif (options._hydrationMismatch)\n\t\t\t\toptions._hydrationMismatch(newVNode, excessDomChildren);\n\t\t\tisHydrating = false;\n\t\t}\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = NULL;\n\t}\n\n\tif (nodeType == NULL) {\n\t\t// During hydration, we still have to split merged text from SSR'd HTML.\n\t\tif (oldProps !== newProps && (!isHydrating || dom.data != newProps)) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\t// If excessDomChildren was not null, repopulate it with the current element's children:\n\t\texcessDomChildren = excessDomChildren && slice.call(dom.childNodes);\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\t// If we are in a situation where we are not hydrating but are using\n\t\t// existing DOM (e.g. replaceNode) we should read the existing DOM\n\t\t// attributes to diff them\n\t\tif (!isHydrating && excessDomChildren != NULL) {\n\t\t\toldProps = {};\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i];\n\t\t\t\toldProps[value.name] = value.value;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in oldProps) {\n\t\t\tvalue = oldProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\toldHtml = value;\n\t\t\t} else if (!(i in newProps)) {\n\t\t\t\tif (\n\t\t\t\t\t(i == 'value' && 'defaultValue' in newProps) ||\n\t\t\t\t\t(i == 'checked' && 'defaultChecked' in newProps)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsetProperty(dom, i, NULL, value, namespace);\n\t\t\t}\n\t\t}\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i == 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i == 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i == 'value') {\n\t\t\t\tinputValue = value;\n\t\t\t} else if (i == 'checked') {\n\t\t\t\tchecked = value;\n\t\t\t} else if (\n\t\t\t\t(!isHydrating || typeof value == 'function') &&\n\t\t\t\toldProps[i] !== value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\tif (\n\t\t\t\t!isHydrating &&\n\t\t\t\t(!oldHtml ||\n\t\t\t\t\t(newHtml.__html != oldHtml.__html && newHtml.__html != dom.innerHTML))\n\t\t\t) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\t\tdiffChildren(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tnewVNode.type == 'template' ? dom.content : dom,\n\t\t\t\tisArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnodeType == 'foreignObject' ? XHTML_NAMESPACE : namespace,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\texcessDomChildren\n\t\t\t\t\t? excessDomChildren[0]\n\t\t\t\t\t: oldVNode._children && getDomSibling(oldVNode, 0),\n\t\t\t\tisHydrating,\n\t\t\t\trefQueue\n\t\t\t);\n\n\t\t\t// Remove children that are not part of any vnode.\n\t\t\tif (excessDomChildren != NULL) {\n\t\t\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\t\t\tremoveNode(excessDomChildren[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// As above, don't diff props during hydration\n\t\tif (!isHydrating) {\n\t\t\ti = 'value';\n\t\t\tif (nodeType == 'progress' && inputValue == NULL) {\n\t\t\t\tdom.removeAttribute('value');\n\t\t\t} else if (\n\t\t\t\tinputValue != UNDEFINED &&\n\t\t\t\t// #2756 For the <progress>-element the initial value is 0,\n\t\t\t\t// despite the attribute not being present. When the attribute\n\t\t\t\t// is missing the progress bar is treated as indeterminate.\n\t\t\t\t// To fix that we'll always update it when it is 0 for progress elements\n\t\t\t\t(inputValue !== dom[i] ||\n\t\t\t\t\t(nodeType == 'progress' && !inputValue) ||\n\t\t\t\t\t// This is only for IE 11 to fix <select> value not being updated.\n\t\t\t\t\t// To avoid a stale select value we need to set the option.value\n\t\t\t\t\t// again, which triggers IE11 to re-evaluate the select value\n\t\t\t\t\t(nodeType == 'option' && inputValue != oldProps[i]))\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, inputValue, oldProps[i], namespace);\n\t\t\t}\n\n\t\t\ti = 'checked';\n\t\t\tif (checked != UNDEFINED && checked != dom[i]) {\n\t\t\t\tsetProperty(dom, i, checked, oldProps[i], namespace);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {Ref<any> & { _unmount?: unknown }} ref\n * @param {any} value\n * @param {VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') {\n\t\t\tlet hasRefUnmount = typeof ref._unmount == 'function';\n\t\t\tif (hasRefUnmount) {\n\t\t\t\t// @ts-ignore TS doesn't like moving narrowing checks into variables\n\t\t\t\tref._unmount();\n\t\t\t}\n\n\t\t\tif (!hasRefUnmount || value != NULL) {\n\t\t\t\t// Store the cleanup function on the function\n\t\t\t\t// instance object itself to avoid shape\n\t\t\t\t// transitioning vnode\n\t\t\t\tref._unmount = ref(value);\n\t\t\t}\n\t\t} else ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {VNode} vnode The virtual node to unmount\n * @param {VNode} parentVNode The parent of the VNode that initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current == vnode._dom) {\n\t\t\tapplyRef(r, NULL, parentVNode);\n\t\t}\n\t}\n\n\tif ((r = vnode._component) != NULL) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = NULL;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentVNode,\n\t\t\t\t\tskipRemove || typeof vnode.type != 'function'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove) {\n\t\tremoveNode(vnode._dom);\n\t}\n\n\tvnode._component = vnode._parent = vnode._dom = UNDEFINED;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n", "import { EMPTY_OBJ, NULL } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { slice } from './util';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to render into\n * @param {import('./internal').PreactElement | object} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\t// https://github.com/preactjs/preact/issues/3794\n\tif (parentDom == document) {\n\t\tparentDom = document.documentElement;\n\t}\n\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we are in\n\t// hydration mode or not by passing the `hydrate` function instead of a DOM\n\t// element..\n\tlet isHydrating = typeof replaceNode == 'function';\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? NULL\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\n\tvnode = ((!isHydrating && replaceNode) || parentDom)._children =\n\t\tcreateElement(Fragment, NULL, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [],\n\t\trefQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\tvnode,\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.namespaceURI,\n\t\t!isHydrating && replaceNode\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t\t? NULL\n\t\t\t\t: parentDom.firstChild\n\t\t\t\t\t? slice.call(parentDom.childNodes)\n\t\t\t\t\t: NULL,\n\t\tcommitQueue,\n\t\t!isHydrating && replaceNode\n\t\t\t? replaceNode\n\t\t\t: oldVNode\n\t\t\t\t? oldVNode._dom\n\t\t\t\t: parentDom.firstChild,\n\t\tisHydrating,\n\t\trefQueue\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode, refQueue);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, hydrate);\n}\n", "import { assign, slice } from './util';\nimport { createVNode } from './create-element';\nimport { NULL, UNDEFINED } from './constants';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its\n * children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used\n * as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tlet defaultProps;\n\n\tif (vnode.type && vnode.type.defaultProps) {\n\t\tdefaultProps = vnode.type.defaultProps;\n\t}\n\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse if (props[i] == UNDEFINED && defaultProps != UNDEFINED) {\n\t\t\tnormalizedProps[i] = defaultProps[i];\n\t\t} else {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 2) {\n\t\tnormalizedProps.children =\n\t\t\targuments.length > 3 ? slice.call(arguments, 2) : children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tNULL\n\t);\n}\n", "import { NULL } from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw the error that was caught (except\n * for unmounting when this parameter is the highest parent that was being\n * unmounted)\n * @param {import('../internal').VNode} [oldVNode]\n * @param {import('../internal').ErrorInfo} [errorInfo]\n */\nexport function _catchError(error, vnode, oldVNode, errorInfo) {\n\t/** @type {import('../internal').Component} */\n\tlet component,\n\t\t/** @type {import('../internal').ComponentType} */\n\t\tctor,\n\t\t/** @type {boolean} */\n\t\thandled;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tctor = component.constructor;\n\n\t\t\t\tif (ctor && ctor.getDerivedStateFromError != NULL) {\n\t\t\t\t\tcomponent.setState(ctor.getDerivedStateFromError(error));\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != NULL) {\n\t\t\t\t\tcomponent.componentDidCatch(error, errorInfo || {});\n\t\t\t\t\thandled = component._dirty;\n\t\t\t\t}\n\n\t\t\t\t// This is an error boundary. Mark it as having bailed out, and whether it was mid-hydration.\n\t\t\t\tif (handled) {\n\t\t\t\t\treturn (component._pendingError = component);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n", "import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "import { Dispatch } from 'preact/hooks';\nimport { ItemProps } from '@/types/props';\nimport { PromptPilotAction } from '@/reducers/appReducer';\n\nexport function dispatchSetVisibility(dispatch: Dispatch<PromptPilotAction>, visibility: boolean) {\n    dispatch({\n        type: 'SET_VISIBILITY',\n        payload: visibility,\n    });\n}\n\nexport function dispatchSetPosition(\n    dispatch: Dispatch<PromptPilotAction>,\n    contextPosition: {\n        offset_x: number;\n        offset_y: number;\n        x: number;\n        y: number;\n    },\n) {\n    dispatch({\n        type: 'SET_POSITION',\n        payload: contextPosition,\n    });\n}\n\nexport function dispatchSetTextarea(dispatch: Dispatch<PromptPilotAction>, textarea: PilotTextArea | null) {\n    dispatch({\n        type: 'SET_TEXTAREA',\n        payload: textarea,\n    });\n}\n\nexport function dispatchSetTab(dispatch: Dispatch<PromptPilotAction>, category: string) {\n    dispatch({\n        type: 'SET_TAB',\n        payload: category,\n    });\n}\n\nexport function dispatchSetItems(dispatch: Dispatch<PromptPilotAction>, type: 'tag' | 'lora' | 'simple', items: ItemProps[]) {\n    dispatch({\n        type: 'SET_ITEMS',\n        payload: {\n            type: type,\n            items,\n        },\n    });\n}\n\nexport function dispatchSetSelectedItem(dispatch: Dispatch<PromptPilotAction>, item: ItemProps) {\n    dispatch({\n        type: 'SET_SELECTED_ITEM',\n        payload: item,\n    });\n}\n\nexport function dispatchSetMessage(dispatch: Dispatch<PromptPilotAction>, type: 'tag' | 'lora' | 'simple', message: string) {\n    dispatch({\n        type: 'SET_MESSAGE',\n        payload: {\n            type: type,\n            message: message,\n        },\n    });\n}\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { h } from 'preact';\nimport { usePromptPilot } from '@/components/core/App';\n\nexport const Preview = () => {\n    const { state } = usePromptPilot();\n    return (\n        state.status === 'success' &&\n        state.selectedItem &&\n        state.type === 'lora' && (\n            <div className=\"preview\">\n                <img src={state.selectedItem ? (state.selectedItem.previewFile ?? undefined) : ''}></img>\n            </div>\n        )\n    );\n};\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Fragment, h } from 'preact';\nimport classNames from 'classnames';\nimport { dispatchSetSelectedItem, dispatchSetVisibility } from '@/reducers/dispatchHelper';\nimport { escapeRegex, insertWordIntoPrompt } from '@/utils/editorUtil';\nimport { formatNumberWithUnits } from '@/utils/commonUtil';\nimport { openWiki } from '@/utils/externalUtil';\nimport { useEffect } from 'preact/hooks';\nimport { usePromptPilot } from '@/components/core/App';\nimport { ItemProps } from '@/types/props';\n\nexport const Items = () => {\n    const { state, dispatch } = usePromptPilot();\n\n    useEffect(() => {\n        if (state.selectedItem) {\n            const selectedElement = document.querySelector(`#suggestion-box li.selected`);\n            if (selectedElement) {\n                selectedElement.scrollIntoView({ block: 'nearest' });\n            }\n        }\n    }, [state.selectedItem]);\n\n    const items = state.items.filter((item) => state.selectedCategory === 'all' || String(item.category) === state.selectedCategory);\n\n    const handleSelectItem = (e: h.JSX.TargetedMouseEvent<HTMLUListElement>) => {\n        const target = e.target as HTMLElement;\n        const element = target.closest('li');\n        if (element) {\n            const item = items[+element.dataset.index!];\n            if (item && (state.selectedItem === null || state.selectedItem.value !== item.value)) {\n                dispatchSetSelectedItem(dispatch, item);\n            }\n        }\n    };\n\n    const handleApplyItem = (e: h.JSX.TargetedMouseEvent<HTMLUListElement>) => {\n        const target = e.target as HTMLElement;\n        const element = target.closest('li');\n        if (element) {\n            e.stopPropagation();\n            const item = items[+element.dataset.index!];\n            insertWordIntoPrompt(state);\n            if (target instanceof HTMLAnchorElement) {\n                const tag = item.isOfficial ? item.value : item.consequentTagModel!.value;\n                openWiki(tag);\n            }\n            dispatchSetVisibility(dispatch, false);\n        }\n    };\n\n    let message = undefined;\n    if (state.status === 'loading') {\n        message = 'Loading models...';\n    } else if (state.status === 'error') {\n        message = 'An error occurred. Please reload the page.';\n    } else if (state.message) {\n        message = state.message;\n    }\n\n    return (\n        <ul\n            key={`${state.selectedCategory}_${message}_${items.length}`}\n            class=\"list-container\"\n            onMouseMove={(e) => handleSelectItem(e)}\n            onMouseDown={(e) => handleApplyItem(e)}\n        >\n            {message && (\n                <li key={message} className=\"notice\" data-type=\"\">\n                    {message}\n                </li>\n            )}\n            {!message &&\n                items.map((item, i) => {\n                    return (\n                        <li\n                            key={item.value}\n                            className={classNames(`group${item.category}`, state.selectedItem && state.selectedItem.value === item.value ? 'selected' : '')}\n                            data-index={i}\n                        >\n                            {state.type === 'tag' && <span className={classNames('highlight', item.useCount > 0 ? 'recommend' : null)}></span>}\n                            {state.type === 'tag' && (\n                                <a className=\"wiki\" style={{ visibility: item.postCount > 0 ? '' : 'hidden' }}>\n                                    ?\n                                </a>\n                            )}\n                            <span className=\"title\">\n                                <HighlightedText item={item} />\n                            </span>\n                            {state.type === 'tag' && item.postCount > 0 && <span className=\"post-count\">{formatNumberWithUnits(item.postCount)}</span>}\n                        </li>\n                    );\n                })}\n        </ul>\n    );\n};\n\nconst HighlightedText = ({ item }: { item: ItemProps }) => {\n    const highlightText = (text: string) => {\n        let result: (string | h.JSX.Element)[] = [text];\n\n        item.matchedWords.forEach((matchedWord, wordIndex) => {\n            const escapedWord = escapeRegex(matchedWord.word);\n            const regex = new RegExp(`(${escapedWord})`, 'gi');\n\n            const newResult: (string | h.JSX.Element)[] = [];\n\n            result.forEach((part, partIndex) => {\n                if (typeof part === 'string') {\n                    const segments = part.split(regex);\n                    segments.forEach((segment, segmentIndex) => {\n                        if (segmentIndex % 2 === 1) {\n                            newResult.push(<b key={`${wordIndex}-${partIndex}-${segmentIndex}`}>{segment}</b>);\n                        } else if (segment) {\n                            newResult.push(segment);\n                        }\n                    });\n                } else {\n                    newResult.push(part);\n                }\n            });\n\n            result = newResult;\n        });\n\n        return result;\n    };\n\n    return (\n        <>\n            {highlightText(item.value)}\n            {item.consequentTagModel && (\n                <>\n                    <span></span>\n                    {highlightText(item.consequentTagModel.value)}\n                </>\n            )}\n        </>\n    );\n};\n", "export function debounce<T extends (...args: any[]) => any>(func: T, wait: number) {\n    let debounceTimeout: ReturnType<typeof setTimeout>;\n    return (...args: Parameters<T>) => {\n        clearTimeout(debounceTimeout);\n        debounceTimeout = setTimeout(() => {\n            func(...args);\n        }, wait);\n    };\n}\n\nexport function debounceWithLeadingTrailing<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {\n    let timeout: ReturnType<typeof setTimeout> | null = null;\n    let lastCallTime: number | null = null;\n    let lastArgs: Parameters<T> | null = null;\n    let hasPendingTrailing = false;\n\n    return (...args: Parameters<T>) => {\n        const now = Date.now();\n\n        if (!lastCallTime || now - lastCallTime >= wait) {\n            func(...args);\n            hasPendingTrailing = false;\n        } else {\n            hasPendingTrailing = true;\n            lastArgs = args;\n        }\n        lastCallTime = now;\n\n        if (timeout) clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            if (hasPendingTrailing && lastArgs) {\n                func(...lastArgs);\n            }\n            lastCallTime = null;\n            hasPendingTrailing = false;\n        }, wait);\n    };\n}\n\nexport function formatNumberWithUnits(num: number): string {\n    if (Math.abs(num) >= 1e12) {\n        return (num / 1e12).toFixed(1) + 'T';\n    } else if (Math.abs(num) >= 1e9) {\n        return (num / 1e9).toFixed(1) + 'G';\n    } else if (Math.abs(num) >= 1e6) {\n        return (num / 1e6).toFixed(1) + 'M';\n    } else if (Math.abs(num) >= 1e3) {\n        return (num / 1e3).toFixed(1) + 'K';\n    } else {\n        return num.toString();\n    }\n}\n", "import { ItemProps } from '@/types/props';\nimport { EXTENSION_ID } from '@/const/common';\nimport { ResponseData } from '@/types/api';\nimport { TagModel } from '@/types/model';\nimport { debounceWithLeadingTrailing } from '@/utils/commonUtil';\n\nlet tagModels: Record<string, TagModel>;\nlet tagIndex: Record<string, Record<string, TagModel>>;\nexport let alwaysUnderscoreTags: Set<string>;\nexport let alwaysSpaceTags: Set<string>;\n\nexport function initializeTagModels(resData: ResponseData | undefined): void {\n    if (!resData) {\n        return;\n    }\n    alwaysUnderscoreTags = new Set();\n    (window.opts[`${EXTENSION_ID}_always_underscore_tags`] as string).split(/[\\n,]/).forEach((tag: string) => {\n        tag = tag.trim().replace(/_/g, ' ');\n        if (tag) {\n            alwaysUnderscoreTags.add(tag);\n        }\n    });\n\n    alwaysSpaceTags = new Set();\n    (window.opts[`${EXTENSION_ID}_always_space_tags`] as string).split(/[\\n,]/).forEach((tag: string) => {\n        tag = tag.trim().replace(/_/g, ' ');\n        if (tag) {\n            alwaysSpaceTags.add(tag);\n        }\n    });\n\n    tagModels = {};\n    Object.entries(resData.tagModels).forEach(([tag, data]) => {\n        const splitTag = tag.split(/[ _-]/g);\n        const tagModel: TagModel = tagModels[tag] ?? {\n            value: tag,\n            values: tag.split(/[ _-]/g),\n            flatValue: splitTag.join(''),\n            category: data.category,\n            useCount: data.use_count,\n            postCount: data.post_count,\n            consequentTagModel: undefined,\n            isOfficial: true,\n        };\n        tagModel.isOfficial = true;\n        for (const alias of data.aliases) {\n            const splitAlias = alias.split(/[ _-]/g);\n            const aliasTagModel = tagModels[alias] ?? {\n                value: alias,\n                values: alias.split(/[ _-]/g),\n                flatValue: splitAlias.join(''),\n                category: data.category,\n                useCount: data.use_count,\n                postCount: data.post_count,\n                consequentTagModel: tagModel,\n                isOfficial: false,\n            };\n            if (aliasTagModel.isOfficial) {\n                aliasTagModel.consequentTagModel = tagModel;\n            } else {\n                tagModels[alias] = aliasTagModel;\n            }\n        }\n        tagModels[tag] = tagModel;\n    });\n\n    buildTagIndex(tagModels);\n}\n\nfunction getPrefixes(tag: string, maxLen = 3): Set<string> {\n    const set: Set<string> = new Set();\n    for (const t of tag.split(/[ _-]/g)) {\n        const len = Math.min(maxLen, t.length);\n        for (let i = 1; i <= len; i++) {\n            set.add(t.substring(0, i));\n        }\n    }\n    return set;\n}\n\nexport function buildTagIndex(tagModels: Record<string, TagModel>): void {\n    tagIndex = {};\n    for (const tagModel of Object.values(tagModels)) {\n        const prefixes = getPrefixes(tagModel.value, 3);\n        for (const p of prefixes) {\n            if (!(p in tagIndex)) {\n                tagIndex[p] = {};\n            }\n            tagIndex[p][tagModel.value] = tagModel;\n        }\n    }\n}\n\nfunction appendTagModel(tagModel: TagModel): void {\n    if (tagModel.value && tagModel.value in tagModels) {\n        return;\n    }\n    tagModels[tagModel.value] = tagModel;\n    const prefixes = getPrefixes(tagModel.value, 3);\n    for (const p of prefixes) {\n        if (!(p in tagIndex)) {\n            tagIndex[p] = {};\n        }\n        tagIndex[p][tagModel.value] = tagModel;\n    }\n}\n\nexport function getTagModel(tag: string): TagModel | undefined {\n    return tagModels[tag];\n}\n\nexport function searchTag(query: string, priorityTags: string[]): ItemProps[] {\n    const queries = query\n        .toLowerCase()\n        .split(/[ _-]/g)\n        .filter((q) => q.trim() !== '');\n    let joinedQuery: string | undefined;\n    if (queries.length > 1) {\n        joinedQuery = queries.join('');\n    }\n\n    const priorityTagSet = new Set(priorityTags);\n    let resultList: ItemProps[] = [];\n    const resultKeySet: Record<string, boolean> = {};\n    queries.forEach((queryForCandidate) => {\n        const prefixKey = queryForCandidate.length > 3 ? queryForCandidate.slice(0, 3) : queryForCandidate;\n        const candidateTagList = tagIndex[prefixKey];\n        for (const key in candidateTagList) {\n            if (key in resultKeySet) {\n                continue;\n            }\n            const tagModel = candidateTagList[key];\n\n            const matchedWords: { word: string; index: number }[] = [];\n            if (joinedQuery && tagModel.value.startsWith(joinedQuery)) {\n                for (let i = 0; i < queries.length; i++) {\n                    matchedWords.push({ word: queries[i], index: i });\n                }\n            } else {\n                const matchedQueryIndices: Record<number, boolean> = {};\n                for (const query of queries) {\n                    if (!(0 in matchedQueryIndices) && tagModel.flatValue.startsWith(query)) {\n                        matchedWords.push({ word: query, index: 0 });\n                        matchedQueryIndices[0] = true;\n                        continue;\n                    }\n                    for (let i = 0; i < tagModel.values.length; i++) {\n                        if (!(i in matchedQueryIndices) && tagModel.values[i].startsWith(query)) {\n                            matchedWords.push({ word: query, index: i });\n                            matchedQueryIndices[i] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matchedWords.length > 0) {\n                const props: ItemProps = {\n                    ...tagModel,\n                    isPriority: priorityTagSet.has(tagModel.value),\n                    matchedWords: matchedWords,\n                    view: null,\n                    previewFile: '',\n                };\n                resultList.push(props);\n                resultKeySet[key] = true;\n            }\n        }\n    });\n\n    const consequentTagMatchCount = resultList\n        .filter((r) => !r.consequentTagModel)\n        .reduce<Record<string, number>>((acc, r) => {\n            acc[r.value] = r.matchedWords.length;\n            return acc;\n        }, {});\n    resultList = resultList.filter((r) => {\n        if (!r.consequentTagModel) return true;\n        const consequentTag = r.consequentTagModel.value;\n        return !(consequentTag in consequentTagMatchCount) || consequentTagMatchCount[consequentTag] < r.matchedWords.length;\n    });\n\n    const resultTagCount: Record<string, number> = {};\n    const resultCount: Record<string, number> = {};\n    resultList.forEach((r) => {\n        r.matchedWords.forEach((m) => {\n            if (!resultTagCount[m.word]) {\n                resultTagCount[m.word] = 0;\n            }\n            resultTagCount[m.word] += 1;\n        });\n    });\n    resultList.forEach((r) => {\n        resultCount[r.value] = r.matchedWords.reduce((acc, m) => acc + resultTagCount[m.word], 0);\n    });\n\n    resultList = resultList.sort((a, b) => compare(a, b, query, joinedQuery, queries, resultCount));\n    const groupCounter: Record<string, number> = {};\n    for (const key of ['0', '1', '3', '4', '5', 'custom']) {\n        groupCounter[key] = window.opts[`${EXTENSION_ID}_max_results_group${key}`] as number;\n    }\n\n    return resultList.filter((r) => {\n        if (groupCounter[r.category] < 0 || groupCounter[r.category] > 0) {\n            groupCounter[r.category] -= 1;\n            return true;\n        }\n        return false;\n    });\n}\n\nfunction compare(\n    self: ItemProps,\n    other: ItemProps,\n    query: string,\n    joinedQuery: string | undefined,\n    queries: string[],\n    resultCount: Record<string, number>,\n): number {\n    if (self.isPriority && !other.isPriority) return -1;\n    if (!self.isPriority && other.isPriority) return 1;\n\n    if (self.value === query || (joinedQuery && self.value === joinedQuery)) return -1;\n    if (other.value === query || (joinedQuery && other.value === joinedQuery)) return 1;\n\n    if (other.matchedWords.length !== self.matchedWords.length) {\n        return other.matchedWords.length - self.matchedWords.length;\n    } else if (queries.length === self.matchedWords.length) {\n        for (let i = 0; i < self.matchedWords.length; i++) {\n            if (self.matchedWords[i].index !== other.matchedWords[i].index) {\n                return self.matchedWords[i].index - other.matchedWords[i].index;\n            }\n        }\n    }\n\n    if (other.useCount !== self.useCount) {\n        return other.useCount - self.useCount;\n    }\n    const count = resultCount[self.value] - resultCount[other.value];\n    if (count !== 0) {\n        return count;\n    }\n    if (other.postCount !== self.postCount) {\n        return other.postCount - self.postCount;\n    }\n\n    return self.value < other.value ? -1 : 1;\n}\n\nexport const debounceSearchWithApi = debounceWithLeadingTrailing((query: string, callback: (results: ItemProps[]) => void): void => {\n    const endpoint = 'https://danbooru.donmai.us/autocomplete.json';\n    let apiUrl = endpoint;\n    apiUrl += `?search[query]=${encodeURIComponent(query)}`;\n    apiUrl += `&search[type]=tag`;\n    apiUrl += `&limit=${50}`;\n    apiUrl += `&version=1`;\n\n    let resultSet: ItemProps[] = [];\n    fetch(apiUrl)\n        .then(async (res) => {\n            if (!res.ok) {\n                console.error('Error fetching tag data:', res.statusText);\n                callback(resultSet);\n                return;\n            }\n            const json = await res.json();\n            resultSet = json.map((item: { label: string; category: number; post_count: number; antecedent: string }): ItemProps => {\n                let tag;\n                let consequentTagModel = null;\n                if (item.antecedent) {\n                    tag = item.antecedent;\n                    consequentTagModel = tagModels[item.label];\n                } else {\n                    tag = item.label;\n                }\n                return {\n                    value: tag,\n                    category: item.category.toString(),\n                    matchedWords: [],\n                    useCount: 0,\n                    postCount: item.post_count,\n                    consequentTagModel: consequentTagModel,\n                    isOfficial: consequentTagModel === undefined,\n                    isPriority: false,\n                    view: null,\n                    previewFile: null,\n                };\n            });\n            resultSet.forEach((r) => {\n                const splitTag = r.value.split(/[ _-]/g);\n                appendTagModel({\n                    ...r,\n                    values: splitTag,\n                    flatValue: splitTag.join(''),\n                });\n            });\n            callback(resultSet);\n        })\n        .catch((err) => {\n            console.error('Error fetching tag data:', err);\n            callback(resultSet);\n        });\n}, 1100);\n", "import { AppProps, ItemProps } from '@/types/props';\nimport * as db_tag from '@/services/tagService';\nimport { EXTENSION_ID } from '@/const/common';\n\ninterface TextInsertionData {\n    range: {\n        start: number;\n        end: number;\n    };\n    insertText: string;\n}\n\nexport function insertWordIntoPrompt(state: AppProps) {\n    let itemProps: ItemProps | undefined;\n    if (state.selectedItem) {\n        itemProps = state.selectedItem;\n    }\n    if (!itemProps) {\n        return;\n    }\n\n    let insertionData: TextInsertionData;\n    if (state.type === 'tag') {\n        insertionData = getTagInsertionData(state, itemProps);\n    } else if (state.type === 'lora') {\n        insertionData = getLoraInsertionData(state, itemProps);\n    } else if (state.type === 'simple') {\n        insertionData = getSuggestionInsertionData(state, itemProps);\n    } else {\n        return;\n    }\n\n    // TODO const usingExecCommand = window.promptPilot.config[`using_execCommand`] as boolean;\n    const usingExecCommand = true;\n\n    const textarea = state.textarea!;\n    if (usingExecCommand) {\n        textarea.focus();\n        textarea.setSelectionRange(insertionData.range.start, insertionData.range.end);\n        document.execCommand('insertText', false, insertionData.insertText);\n    } else {\n        const val = textarea.value;\n        textarea.value = val.slice(0, insertionData.range.start) + insertionData.insertText + val.slice(insertionData.range.end);\n    }\n    textarea.selectionStart = textarea.selectionEnd = insertionData.range.start + insertionData.insertText.length;\n}\n\nfunction getTagInsertionData(state: AppProps, props: ItemProps): TextInsertionData {\n    const { promptInfo, insertionInfo } = state.parseResult;\n\n    const activeWord = promptInfo.words[promptInfo.activeWordIndex];\n    let startPosition = activeWord.position;\n    let offset = -1;\n    const tags: string[] = [];\n    tags.push(props.value);\n    if (props.consequentTagModel) {\n        tags.push(props.consequentTagModel.value);\n    }\n    const insertionRange = promptInfo.prompt.substring(startPosition, promptInfo.caretPosition);\n    for (const wordInfo of splitStringWithIndices(insertionRange, /[ _-]/g)) {\n        for (const tag of tags) {\n            if (wordInfo.word === '') {\n                continue;\n            }\n            const escapedPart = escapeRegex(unescapePrompt(wordInfo.word));\n            const match = new RegExp(`(?:^|[ _-])${escapedPart}`, 'gi').exec(tag);\n            if (match && match.index !== -1) {\n                if (offset === -1 || offset > wordInfo.position) {\n                    offset = wordInfo.position;\n                }\n            }\n        }\n    }\n    if (offset > -1) {\n        startPosition += offset;\n    }\n\n    let insertTag = props.isOfficial ? props.value : props.consequentTagModel!.value;\n    const source = (window.opts[`${EXTENSION_ID}_tag_source`] as string).replace(/\\./g, '_');\n    const delimiter = (window.opts[`${EXTENSION_ID}_${source}_${props.category}_tag_delimiter`] as string) ?? 'auto';\n    if (!db_tag.alwaysSpaceTags.has(insertTag)) {\n        let replaceToUnderscore = false;\n        if (db_tag.alwaysUnderscoreTags.has(insertTag)) {\n            replaceToUnderscore = true;\n        } else if (delimiter === 'underscore') {\n            replaceToUnderscore = true;\n        } else if (delimiter === 'auto') {\n            replaceToUnderscore = promptInfo.inputtingString.includes('_');\n        }\n        if (replaceToUnderscore) {\n            insertTag = insertTag.replace(/ /g, '_');\n        }\n    }\n\n    if (insertionInfo.needPrependComma) {\n        insertTag = ', ' + insertTag;\n    } else if (offset <= 0 && insertionInfo.needPrependSpace) {\n        insertTag = ' ' + insertTag;\n    }\n    insertTag = escapePrompt(insertTag);\n\n    insertTag += ', ';\n    return { range: { start: startPosition, end: promptInfo.caretPosition }, insertText: insertTag };\n}\n\nfunction getLoraInsertionData(state: AppProps, props: ItemProps): TextInsertionData {\n    const { promptInfo } = state.parseResult;\n\n    const activeWord = promptInfo.words[promptInfo.activeWordIndex];\n    const startPosition = activeWord.position;\n    let loraName = props.value;\n    const match = promptInfo.prompt.substring(startPosition).match(/^<(?:lora|lyco):[^<>:]+(:.+>)/i);\n    let caret = promptInfo.caretPosition;\n    if (match) {\n        caret = startPosition + match[0].length;\n        loraName += match[1];\n    } else {\n        loraName += ':1>';\n    }\n    loraName += ' ';\n    return { range: { start: startPosition, end: caret }, insertText: loraName };\n}\n\nfunction getSuggestionInsertionData(state: AppProps, props: ItemProps): TextInsertionData {\n    const { promptInfo, insertionInfo } = state.parseResult;\n\n    const activeWord = promptInfo.words[promptInfo.activeWordIndex];\n    const startPosition = activeWord.position;\n    const tag = db_tag.getTagModel(props.value);\n    const category = tag?.category ?? 'custom';\n    let word = escapePrompt(props.value);\n\n    const source = (window.opts[`${EXTENSION_ID}_tag_source`] as string).replace(/\\./g, '_');\n    const delimiter = (window.opts[`${EXTENSION_ID}_${source}_${category}_tag_delimiter`] as string) ?? 'auto';\n    if (!db_tag.alwaysSpaceTags.has(word)) {\n        let replaceToUnderscore = false;\n        if (db_tag.alwaysUnderscoreTags.has(word)) {\n            replaceToUnderscore = true;\n        } else if (delimiter === 'underscore') {\n            replaceToUnderscore = true;\n        } else if (delimiter === 'auto') {\n            replaceToUnderscore = promptInfo.inputtingString.includes('_');\n        }\n        if (replaceToUnderscore) {\n            word = word.replace(/ /g, '_');\n        }\n    }\n\n    if (insertionInfo.needPrependComma) {\n        word = ', ' + word;\n    } else if (insertionInfo.needPrependSpace) {\n        word = ' ' + word;\n    }\n\n    word += ', ';\n    return { range: { start: startPosition, end: promptInfo.caretPosition }, insertText: word };\n}\n\nexport function htmlEncode(str: string): string {\n    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\nexport function escapeRegex(str: string): string {\n    return str.replace(/[.*+?^${}()|\\[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function escapePrompt(str: string): string {\n    return str.replace(/[{}()\\[\\]\\\\]/g, '\\\\$&');\n}\n\nexport function unescapePrompt(str: string): string {\n    let props = '';\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            if (i + 1 < str.length) {\n                props += str[i + 1];\n                i++;\n            } else {\n                props += '\\\\';\n            }\n        } else {\n            props += str[i];\n        }\n    }\n    return props;\n}\n\nexport function splitStringWithIndices(input: string, delimiter: RegExp): { word: string; position: number }[] {\n    const props: { word: string; position: number }[] = [];\n    const regex = delimiter;\n    let match: RegExpExecArray | null;\n    let lastIndex = 0;\n\n    while ((match = regex.exec(input)) !== null) {\n        props.push({ word: input.slice(lastIndex, match.index), position: lastIndex });\n        lastIndex = regex.lastIndex;\n    }\n\n    props.push({ word: input.slice(lastIndex), position: lastIndex });\n    return props;\n}\n", "import { EXTENSION_ID } from '@/const/common';\n\nexport const openWiki = (title: string) => {\n    if (title) {\n        title = title.replace(' ', '_');\n        if (/^[0-9]+$/.test(title)) {\n            title = `~${title}`;\n        }\n        const domain = window.opts[`${EXTENSION_ID}_tag_source`] as string;\n        window.open(`https://${domain}/wiki_pages/${encodeURIComponent(title)}`);\n    }\n};\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { h } from 'preact';\nimport classNames from 'classnames';\nimport { dispatchSetTab } from '@/reducers/dispatchHelper';\nimport { usePromptPilot } from '@/components/core/App';\n\nexport const Tabs = () => {\n    const { state, dispatch } = usePromptPilot();\n\n    const handleSelectTab = (category: string) => {\n        dispatchSetTab(dispatch, category);\n    };\n\n    const tabDefines = [\n        ['all', 'ALL'],\n        ['0', 'Gen'],\n        ['1', 'Art'],\n        ['3', 'Copy'],\n        ['4', 'Chara'],\n        ['5', 'Meta'],\n    ];\n    return (\n        <div className={classNames('tab-container', state.status === 'success' && state.type === 'tag' ? '' : 'no-tab')}>\n            {tabDefines.map(([category, title]) => (\n                <div\n                    key={category}\n                    className={classNames('tab', `group${category}`, state.selectedCategory === category ? 'selected' : '')}\n                    onClick={() => handleSelectTab(category)}\n                >\n                    {title}\n                </div>\n            ))}\n        </div>\n    );\n};\n", "import { EXTENSION_ID } from '@/const/common';\nimport { AppProps } from '@/types/props';\n\nexport function isVisible(state: AppProps) {\n    if (!state.isVisible) {\n        return false;\n    }\n    if (!state.textarea) {\n        return false;\n    }\n    const { promptInfo, insertionInfo } = state.parseResult;\n\n    if (insertionInfo.isMetaBlock) {\n        return false;\n    }\n    if (promptInfo.activeWordIndex >= 0) {\n        const activeWord = promptInfo.words[promptInfo.activeWordIndex];\n        if (activeWord.type === 'lora' && promptInfo.inputtingString === '') {\n            return false;\n        }\n    }\n\n    if (!window.opts[`${EXTENSION_ID}_suggest_enabled`] && promptInfo.inputtingString === '') {\n        return false;\n    }\n\n    return true;\n}\n\nexport function calcContextPosition(state: AppProps): {\n    offset_x: number;\n    offset_y: number;\n    x: number;\n    y: number;\n} {\n    const textarea = state.textarea;\n    if (!textarea) {\n        return {\n            offset_x: 0,\n            offset_y: 0,\n            x: 0,\n            y: 0,\n        };\n    }\n    const dummy = textarea.dummy;\n    const caret = dummy.caret;\n\n    const caretIndex = textarea.selectionEnd;\n    const textBeforeCaret = textarea.value.slice(0, caretIndex);\n    const textAfterCaret = textarea.value.slice(caretIndex);\n\n    dummy.textContent = textBeforeCaret;\n    caret.textContent = textAfterCaret[0] || '\\u200b';\n    dummy.appendChild(caret);\n\n    const rect = caret.getBoundingClientRect();\n    const computedStyle = window.getComputedStyle(textarea);\n\n    let lineHeight: number;\n    if (computedStyle.lineHeight === 'normal') {\n        const fontSize = parseFloat(computedStyle.fontSize.replace(/[^\\d\\.]+/, ''));\n        lineHeight = fontSize * 1.2;\n    } else {\n        lineHeight = parseFloat(computedStyle.lineHeight.replace(/[^\\d\\.]+/, ''));\n    }\n    const textareaRect = textarea.getBoundingClientRect();\n    const x = rect.left - textareaRect.left - textarea.scrollLeft;\n    const y = rect.top - textareaRect.top - textarea.scrollTop + lineHeight;\n\n    return {\n        offset_y: textareaRect.top + window.scrollY,\n        offset_x: textareaRect.left + window.scrollX,\n        x: x,\n        y: y,\n    };\n}\n", "import { AppProps } from '@/types/props';\nimport { isVisible } from '@/utils/uiUtil';\n\nexport const setPosition = ({ offset_x, offset_y, x, y }: { offset_x: number; offset_y: number; x: number; y: number }) => ({\n    top: `${offset_y}px`,\n    left: `${offset_x}px`,\n    transform: `translate(${x}px, ${y}px)`,\n});\n\nexport const setDisplay = (state: AppProps) => (isVisible(state) ? {} : { display: 'none' });\n", "import { InsertionInfo, ParseResult, PromptInfo, Word } from '@/types/props';\n\ntype NestType = 'root' | 'paren' | 'square' | 'curly' | 'lora';\n\nconst openerToType: Record<string, NestType> = {\n    '(': 'paren',\n    '[': 'square',\n    '{': 'curly',\n    '<': 'lora',\n};\n\nconst closerToType: Record<string, NestType> = {\n    ')': 'paren',\n    ']': 'square',\n    '}': 'curly',\n    '>': 'lora',\n};\n\nconst closerForType: Record<NestType, string> = {\n    root: '',\n    paren: ')',\n    square: ']',\n    curly: '}',\n    lora: '>',\n};\n\nconst delimiters: Record<NestType, Set<string>> = {\n    root: new Set<string>([',']),\n    paren: new Set<string>([',']),\n    square: new Set<string>([',', ':', '|']),\n    curly: new Set<string>([',', '|']),\n    lora: new Set<string>(),\n};\n\nconst delimitersWithoutComma = new Set<string>([',', '|', ':', '(', '[', '{', '<']);\n\n// length of the string \"lora:\" or \"lyco:\"\nconst PREFIX_LENGTH = 5;\n\nconst metaKeywords = ['BREAK', 'AND', 'ADDCOMM', 'ADDBASE', 'ADDCOL', 'ADDROW'];\n\nconst dynamicPromptRegex = /\\{([\\d-]+\\$\\$(?:[^\\}]+?\\$\\$)?)(.*)\\}/g;\n\nconst matchMetaKeywordRegex = new RegExp(`\\\\b(${metaKeywords.join('|')})\\\\b`, 'g');\n\nfunction makeWordData(nestType: NestType, position: number): Word {\n    const wordType = nestType === 'lora' ? 'lora' : 'tag';\n    return {\n        value: '',\n        position: position,\n        type: wordType,\n        isActive: false,\n    };\n}\n\nexport function updatePromptState(prompt: string, caret: number): ParseResult {\n    const promptInfo: PromptInfo = {\n        prompt: prompt,\n        caretPosition: caret,\n        inputtingString: '',\n        activeWordIndex: -1,\n        words: [] as Word[],\n    };\n\n    const insertionInfo: InsertionInfo = {\n        isMetaBlock: false,\n        needPrependComma: false,\n        needPrependSpace: false,\n    };\n\n    prompt = prompt.replace(matchMetaKeywordRegex, (match) => ','.padEnd(match.length, '\\0'));\n    prompt = prompt.replace(dynamicPromptRegex, (_, group1, group2) => {\n        const stars = '\\0'.repeat(group1.length);\n        return `{${stars}${group2}}`;\n    });\n\n    const nestTypes: NestType[] = ['root'];\n    let isEscaped = false;\n    let delimiter: string | undefined;\n    let isNewLine = true;\n\n    function flush(word: Word) {\n        word.value = word.value.trim();\n        if (word.isActive || word.value !== '') {\n            promptInfo.words.push(word);\n            isNewLine = false;\n            delimiter = undefined;\n        }\n    }\n\n    function updateContextState(char: string) {\n        if (char === '\\n') {\n            isNewLine = true;\n        } else if (delimitersWithoutComma.has(char)) {\n            delimiter = char;\n        }\n    }\n\n    function updatePrependFlags(word: Word) {\n        if (word.isActive && promptInfo.words.length > 0) {\n            if (delimiter === undefined) {\n                insertionInfo.needPrependComma = true;\n                if (!isNewLine) {\n                    insertionInfo.needPrependSpace = true;\n                }\n            } else if (delimiter === ',') {\n                insertionInfo.needPrependSpace = true;\n            }\n        }\n    }\n\n    function setActiveWordData(word: Word) {\n        word.isActive = true;\n        let inputtingString = promptInfo.inputtingString;\n        if (isEscaped) {\n            inputtingString += '\\\\';\n            promptInfo.inputtingString = inputtingString;\n        }\n        promptInfo.inputtingString = word.value.trim();\n        promptInfo.activeWordIndex = promptInfo.words.length;\n    }\n\n    let word: Word = makeWordData('root', 0);\n\n    for (let i = 0; i < prompt.length; i++) {\n        const char = prompt[i];\n        if (i === caret) {\n            setActiveWordData(word);\n        }\n\n        const currentNestType: NestType = nestTypes[nestTypes.length - 1];\n\n        if (char === '\\0') {\n            if (word.isActive) {\n                insertionInfo.isMetaBlock = true;\n                insertionInfo.needPrependSpace = true;\n            }\n            word.position++;\n            continue;\n        }\n        if (char === '\\n') {\n            updatePrependFlags(word);\n            flush(word);\n            updateContextState(char);\n            word = makeWordData(currentNestType, i + 1);\n\n            isEscaped = false;\n            continue;\n        }\n        if (isEscaped) {\n            word.value += char;\n            isEscaped = false;\n            continue;\n        }\n        if (char === '\\\\') {\n            isEscaped = true;\n            continue;\n        }\n\n        if (char in openerToType) {\n            let openerType = openerToType[char];\n            if (openerType === 'lora') {\n                openerType = 'root';\n                if (prompt.length - i > PREFIX_LENGTH) {\n                    const loraPrefix = prompt.substring(i + 1, i + PREFIX_LENGTH + 1);\n                    if (loraPrefix === 'lora:' || loraPrefix === 'lyco:') {\n                        openerType = 'lora';\n                    }\n                }\n            }\n            if (openerType !== 'root') {\n                nestTypes.push(openerType);\n\n                if (openerType === 'lora') {\n                    i += PREFIX_LENGTH;\n                    if (i - caret >= 0 && i - caret < PREFIX_LENGTH) {\n                        insertionInfo.isMetaBlock = true;\n                    }\n                }\n                updatePrependFlags(word);\n                flush(word);\n                updateContextState(char);\n                if (openerType === 'lora') {\n                    word = makeWordData(openerType, i + 1);\n                } else {\n                    word = makeWordData(openerType, i);\n                }\n                continue;\n            }\n        }\n\n        if (char in closerToType) {\n            const expectedCloser = closerForType[currentNestType];\n            if (char !== expectedCloser) {\n                word.value += char;\n                continue;\n            }\n            if (currentNestType === 'paren' || currentNestType === 'square') {\n                const colonIndex = word.value.lastIndexOf(':');\n                if (colonIndex >= 0) {\n                    const wordValue = word.value.substring(0, colonIndex);\n                    const weightValue = word.value.substring(colonIndex + 1);\n                    if (isNumber(weightValue)) {\n                        word.value = wordValue;\n                        if (word.isActive && i - caret <= weightValue!.length) {\n                            insertionInfo.isMetaBlock = true;\n                        }\n                    }\n                } else if (currentNestType === 'square') {\n                    if (isNumber(word.value)) {\n                        if (word.isActive && i - caret <= word.value.length) {\n                            insertionInfo.isMetaBlock = true;\n                        }\n                        word.value = '';\n                    }\n                }\n            } else if (currentNestType === 'lora') {\n                const colonIndex = word.value.indexOf(':');\n                if (colonIndex >= 0) {\n                    const loraName = word.value.substring(0, colonIndex);\n                    const multiplier = word.value.substring(colonIndex + 1);\n                    if (word.isActive && i - caret <= multiplier!.length) {\n                        insertionInfo.isMetaBlock = true;\n                    }\n                    word.value = loraName;\n                }\n            }\n            nestTypes.pop();\n\n            updatePrependFlags(word);\n            flush(word);\n            updateContextState(char);\n            word = makeWordData(nestTypes[nestTypes.length - 1], i + 1);\n            continue;\n        }\n\n        if (currentNestType === 'lora') {\n            if (word.value !== '' || char !== ' ') {\n                word.value += char;\n            }\n            continue;\n        }\n\n        if (delimiters[currentNestType]?.has(char)) {\n            updatePrependFlags(word);\n            flush(word);\n            updateContextState(char);\n            word = makeWordData(currentNestType, i + 1);\n            continue;\n        }\n\n        if (word.value === '') {\n            word.position = i;\n        }\n        word.value += char;\n    }\n\n    if (promptInfo.activeWordIndex < 0) {\n        setActiveWordData(word);\n    }\n    promptInfo.words.forEach((word) => {\n        word.value = word.value.replace(/_/g, ' ');\n    });\n    updatePrependFlags(word);\n    flush(word);\n\n    return { promptInfo: promptInfo, insertionInfo: insertionInfo };\n}\n\nfunction isNumber(value: string): boolean {\n    if (value.trim() === '') {\n        return false;\n    }\n    return !isNaN(+value);\n}\n", "import { usePromptPilot } from '@/components/core/App';\nimport { useEffect } from 'preact/hooks';\n\nfunction useTextareaEvent<T extends Event>(eventName: string, handler: (e: T) => void, deps: readonly unknown[] = []) {\n    const { state } = usePromptPilot();\n\n    useEffect(() => {\n        if (!window.pilotIsActive || !state.textarea) return;\n\n        const typedHandler = handler as EventListener;\n        state.textarea.addEventListener(eventName, typedHandler);\n\n        return () => {\n            state.textarea?.removeEventListener(eventName, typedHandler);\n        };\n    }, [state.textarea, eventName, handler, ...deps]);\n}\n\nexport const useMouseEvent = (eventName: 'mousedown' | 'mouseup' | 'mousemove' | 'click', handler: (e: MouseEvent) => void, deps: readonly unknown[] = []) =>\n    useTextareaEvent(eventName, handler, deps);\n\nexport const useKeyboardEvent = (eventName: 'keydown' | 'keyup' | 'keypress' | 'input', handler: (e: KeyboardEvent) => void, deps: readonly unknown[] = []) =>\n    useTextareaEvent(eventName, handler, deps);\n\nexport const useCompositionEvent = (\n    eventName: 'compositionstart' | 'compositionend' | 'compositionupdate',\n    handler: (e: CompositionEvent) => void,\n    deps: readonly unknown[] = [],\n) => useTextareaEvent(eventName, handler, deps);\n", "import { ItemProps } from '@/types/props';\nimport { ResponseData } from '@/types/api';\nimport { SuggestionModel } from '@/types/model';\n\nlet suggestionModels: Record<string, SuggestionModel[]>;\n\nexport function initializeSuggestionModels(resData: ResponseData | undefined): void {\n    if (!resData) {\n        return;\n    }\n    suggestionModels = {};\n    Object.entries(resData.suggestionModels).forEach(([word, record]) => {\n        const sorted = Object.entries(record).sort(([, count1], [, count2]) => count2 - count1);\n        suggestionModels[word] = sorted.map(([word, count]) => ({\n            value: word,\n            count: count,\n        }));\n    });\n}\n\nexport function searchSuggestion(nearestTag: string | undefined, existTags: Set<string>): ItemProps[] {\n    if (!nearestTag) {\n        return [];\n    }\n    const suggestions = suggestionModels[nearestTag];\n    if (!suggestions) return [];\n    const props: ItemProps[] = [];\n    for (const candidate of suggestions) {\n        if (!existTags.has(candidate.value)) {\n            props.push({\n                ...candidate,\n                view: null,\n                isPriority: false,\n                matchedWords: [],\n                category: '',\n                useCount: 0,\n                postCount: 0,\n                consequentTagModel: null,\n                isOfficial: false,\n                previewFile: null,\n            });\n        }\n    }\n    return props;\n}\n", "import * as parser from '@/parsers/promptParser';\nimport { AppProps, PromptInfo } from '@/types/props';\nimport { Dispatch } from 'preact/hooks';\nimport { PromptPilotAction } from '@/reducers/appReducer';\nimport * as db_sg from '@/services/suggestionService';\nimport * as db_tag from '@/services/tagService';\nimport * as db_lora from '@/services/loraService';\nimport { dispatchSetItems, dispatchSetMessage } from '@/reducers/dispatchHelper';\n\nfunction extractPromptInfo(state: AppProps) {\n    const textarea = state.textarea!;\n    const parseResult = parser.updatePromptState(textarea.value, textarea.selectionEnd);\n\n    return parseResult;\n}\n\nfunction collectExistingTags(promptInfo: PromptInfo): Set<string> {\n    return new Set(promptInfo.words.filter((word, i) => i !== promptInfo.activeWordIndex && word.type !== 'lora').map((word) => word.value));\n}\n\nfunction findNearestTag(promptInfo: PromptInfo): string | undefined {\n    for (let i = promptInfo.activeWordIndex - 1; i >= 0; i--) {\n        const word = promptInfo.words[i];\n        if (word.type === 'lora') {\n            continue;\n        }\n        return word.value;\n    }\n    return undefined;\n}\n\nfunction collectPriorityTags(inputtingString: string, nearestTag: string | undefined, existTags: Set<string>): string[] {\n    const suggestions = db_sg.searchSuggestion(nearestTag, existTags);\n    const priorityTag: string[] = [];\n\n    for (const suggestion of suggestions) {\n        if (suggestion.value.startsWith(inputtingString)) {\n            priorityTag.push(suggestion.value);\n        }\n    }\n\n    return priorityTag;\n}\n\nfunction handleTagItems(inputtingString: string, nearestTag: string | undefined, existTags: Set<string>, dispatch: Dispatch<PromptPilotAction>) {\n    if (inputtingString === '') {\n        const suggestions = db_sg.searchSuggestion(nearestTag, existTags);\n        dispatchSetItems(dispatch, 'simple', suggestions);\n        return;\n    }\n\n    const priorityTag = collectPriorityTags(inputtingString, nearestTag, existTags);\n\n    if (inputtingString.startsWith('*') && inputtingString.length > 1) {\n        db_tag.debounceSearchWithApi(inputtingString.substring(1), (resultSet) => {\n            dispatchSetItems(dispatch, 'tag', resultSet);\n        });\n        dispatchSetMessage(dispatch, 'tag', 'Searching for tags via API...');\n    } else {\n        const items = db_tag.searchTag(inputtingString, priorityTag);\n        dispatchSetItems(dispatch, 'tag', items);\n    }\n}\n\nfunction handleLoraItems(inputtingString: string, dispatch: Dispatch<PromptPilotAction>) {\n    const items = db_lora.searchLora(inputtingString);\n    dispatchSetItems(dispatch, 'lora', items);\n}\n\nexport function updateContext(state: AppProps, dispatch: Dispatch<PromptPilotAction>) {\n    const parseResult = extractPromptInfo(state);\n\n    if (state.status !== 'success') {\n        dispatch({\n            type: 'SET_VISIBILITY',\n            payload: true,\n        });\n        return;\n    }\n\n    dispatch({\n        type: 'SET_PARSE_RESULT',\n        payload: parseResult,\n    });\n\n    const { promptInfo } = parseResult;\n\n    const activeWord = promptInfo.words[promptInfo.activeWordIndex];\n    const inputtingString = promptInfo.inputtingString;\n\n    const existTags = collectExistingTags(promptInfo);\n\n    if (activeWord.type !== 'lora') {\n        const nearestTag = findNearestTag(promptInfo);\n        handleTagItems(inputtingString, nearestTag, existTags, dispatch);\n    } else {\n        handleLoraItems(inputtingString, dispatch);\n    }\n}\n", "import { dispatchSetVisibility, dispatchSetPosition, dispatchSetSelectedItem } from '@/reducers/dispatchHelper';\nimport * as parser from '@/parsers/promptParser';\nimport { openWiki } from '@/utils/externalUtil';\nimport { calcContextPosition } from '@/utils/uiUtil';\nimport { insertWordIntoPrompt } from '@/utils/editorUtil';\nimport { ItemProps, Word } from '@/types/props';\nimport { useCompositionEvent, useKeyboardEvent, useMouseEvent } from '@/hooks/useTextareaEvents';\nimport { usePromptPilot } from '@/components/core/App';\nimport { useRef } from 'preact/hooks';\nimport { debounceWithLeadingTrailing } from '@/utils/commonUtil';\nimport { updateContext } from '@/hooks/usePromptContext';\nimport { DEBOUNCE_DELAY } from '@/const/common';\n\nconst debounceUpdateContext = debounceWithLeadingTrailing(updateContext, DEBOUNCE_DELAY);\n\nlet processingPromise: Promise<Word> | undefined;\n\ntype KeyCode = 'Tab' | 'Enter' | 'Backspace' | 'Delete' | 'ArrowDown' | 'ArrowUp' | 'Escape' | 'ArrowLeft' | 'ArrowRight' | 'Home' | 'End';\n\nexport const TextareaEventHandlers = () => {\n    const { state, dispatch } = usePromptPilot();\n    const isWeightMode = useRef(false);\n    const isComposingRef = useRef(false);\n\n    useMouseEvent(\n        'mousedown',\n        (e: MouseEvent) => {\n            if (!e.ctrlKey) {\n                return;\n            }\n            // waiting for the textarea to be updated\n            setTimeout(() => {\n                processingPromise = new Promise((resolve) => {\n                    const textarea = state.textarea!;\n                    const parseResult = parser.updatePromptState(textarea.value, textarea.selectionEnd);\n                    dispatch({\n                        type: 'SET_PARSE_RESULT',\n                        payload: parseResult,\n                    });\n                    const { promptInfo } = parseResult;\n                    const activeWord = promptInfo.words[promptInfo.activeWordIndex];\n                    resolve(activeWord);\n                });\n            }, 50);\n        },\n        [state.textarea],\n    );\n\n    useMouseEvent(\n        'mouseup',\n        (e: MouseEvent) => {\n            if (!e.ctrlKey) {\n                return;\n            }\n            if (!processingPromise) {\n                return;\n            }\n            processingPromise.then((word) => {\n                if (word.type === 'tag') {\n                    openWiki(word.value);\n                }\n            });\n        },\n        [state.textarea],\n    );\n\n    useCompositionEvent(\n        'compositionstart',\n        () => {\n            isComposingRef.current = true;\n        },\n        [state.textarea],\n    );\n\n    useCompositionEvent(\n        'compositionend',\n        () => {\n            isComposingRef.current = false;\n            if (!isWeightMode.current) {\n                dispatchSetPosition(dispatch, calcContextPosition(state));\n                debounceUpdateContext(state, dispatch);\n            }\n        },\n        [state.textarea],\n    );\n\n    useKeyboardEvent(\n        'input',\n        () => {\n            if (isWeightMode.current || isComposingRef.current) {\n                return;\n            }\n            dispatchSetPosition(dispatch, calcContextPosition(state));\n            debounceUpdateContext(state, dispatch);\n        },\n        [state.textarea, state.isVisible, state.status],\n    );\n\n    useKeyboardEvent(\n        'keydown',\n        (e: KeyboardEvent) => {\n            const key = e.key as KeyCode;\n            if (e.ctrlKey && (key === 'ArrowDown' || key === 'ArrowUp')) {\n                isWeightMode.current = true;\n                return;\n            }\n\n            if (!state.isVisible) {\n                return;\n            }\n            if (isComposingRef.current) {\n                return;\n            }\n\n            if (key === 'Escape') {\n                dispatchSetVisibility(dispatch, false);\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n\n            if (!state.items.length) {\n                return;\n            }\n\n            if (key === 'Tab') {\n                const itemProps = state.selectedItem;\n                if (itemProps) {\n                    insertWordIntoPrompt(state);\n                    if (e.shiftKey && state.type === 'tag') {\n                        const tagResult = itemProps as ItemProps;\n                        if (tagResult.isOfficial !== undefined) {\n                            const tag = tagResult.isOfficial ? tagResult.value : tagResult.consequentTagModel!.value;\n                            openWiki(tag);\n                        }\n                    }\n                }\n                e.preventDefault();\n            } else if (key === 'ArrowDown' || key === 'ArrowUp') {\n                if (!e.ctrlKey && !e.shiftKey) {\n                    const direction = key === 'ArrowDown' ? 1 : -1;\n\n                    const filteredItems = state.items.filter((item) => state.selectedCategory === 'all' || String(item.category) === state.selectedCategory);\n\n                    let currentIndex = -1;\n                    if (state.selectedItem) {\n                        currentIndex = filteredItems.findIndex((item) => item.value === state.selectedItem!.value);\n                    }\n\n                    const nextIndex = (currentIndex + direction + filteredItems.length) % filteredItems.length;\n\n                    dispatchSetSelectedItem(dispatch, filteredItems[nextIndex]);\n                    e.preventDefault();\n                }\n            }\n        },\n        [state.textarea, state.isVisible, state.items, state.selectedItem, state.selectedCategory, state.parseResult],\n    );\n\n    useKeyboardEvent(\n        'keyup',\n        (e: KeyboardEvent) => {\n            isWeightMode.current = false;\n\n            if (!state.isVisible) {\n                return;\n            }\n            if (isComposingRef.current) {\n                return;\n            }\n            const key = e.key as KeyCode;\n            if (['ArrowLeft', 'ArrowRight', 'Home', 'End'].includes(key)) {\n                dispatchSetPosition(dispatch, calcContextPosition(state));\n                debounceUpdateContext(state, dispatch);\n                e.preventDefault();\n            }\n        },\n        [state.textarea, state.isVisible],\n    );\n\n    return null;\n};\n", "// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c + ';addEventListener(\"error\",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'\n    ], { type: 'text/javascript' }))));\n    w.onmessage = function (e) {\n        var d = e.data, ed = d.$e$;\n        if (ed) {\n            var err = new Error(ed[0]);\n            err['code'] = ed[1];\n            err.stack = ed[2];\n            cb(err, null);\n        }\n        else\n            cb(null, d);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new i32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return { b: b, r: r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r;\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >> 8) | ((x & 0x00FF) << 8)) >> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i) {\n        if (cd[i])\n            ++l[cd[i] - 1];\n    }\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 1; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p + 7) / 8) | 0; };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    return new u8(v.subarray(s, e));\n};\n/**\n * Codes for errors generated within this library\n */\nexport var FlateErrorCode = {\n    UnexpectedEOF: 0,\n    InvalidBlockType: 1,\n    InvalidLengthLiteral: 2,\n    InvalidDistance: 3,\n    StreamFinished: 4,\n    NoStreamHandler: 5,\n    InvalidHeader: 6,\n    NoCallback: 7,\n    InvalidUTF8: 8,\n    ExtraFieldTooLong: 9,\n    InvalidDate: 10,\n    FilenameTooLong: 11,\n    StreamFinishing: 12,\n    InvalidZipData: 13,\n    UnknownCompressionMethod: 14\n};\n// error codes\nvar ec = [\n    'unexpected EOF',\n    'invalid block type',\n    'invalid length/literal',\n    'invalid distance',\n    'stream finished',\n    'no stream handler',\n    ,\n    'no callback',\n    'invalid UTF-8 data',\n    'extra field too long',\n    'date not in range 1980-2099',\n    'filename too long',\n    'stream finishing',\n    'invalid zip data'\n    // determined by unknown compression method\n];\n;\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, st, buf, dict) {\n    // source length       dict length\n    var sl = dat.length, dl = dict ? dict.length : 0;\n    if (!sl || st.f && !st.l)\n        return buf || new u8(0);\n    var noBuf = !buf;\n    // have to estimate size\n    var resize = noBuf || st.i != 2;\n    // no state\n    var noSt = st.i;\n    // Assumes roughly 33% compression ratio average\n    if (noBuf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                // ensure size\n                if (resize)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8, st.f = final;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                err(1);\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17\n        if (resize)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    err(0);\n                break;\n            }\n            if (!c)\n                err(2);\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n                if (!d)\n                    err(3);\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        err(0);\n                    break;\n                }\n                if (resize)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                if (bt < dt) {\n                    var shift = dl - dt, dend = Math.min(dt, end);\n                    if (shift + bt < 0)\n                        err(3);\n                    for (; bt < dend; ++bt)\n                        buf[bt] = dict[shift + bt];\n                }\n                for (; bt < end; ++bt)\n                    buf[bt] = buf[bt - dt];\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    // don't reallocate for streams or user buffers\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >> 8;\n    d[o + 2] |= v >> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return { t: et, l: 0 };\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return { t: v, l: 1 };\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return { t: new u8(tr), l: mbt };\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return { c: cl.subarray(0, cli), n: s };\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;\n    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;\n    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;\n    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        ++lcfreq[lclt[i] & 31];\n    for (var i = 0; i < lcdt.length; ++i)\n        ++lcfreq[lcdt[i] & 31];\n    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];\n    if (bs >= 0 && flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        var sym = syms[i];\n        if (sym > 255) {\n            var len = (sym >> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (sym >> 23) & 31), p += fleb[len];\n            var dst = sym & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[sym]), p += ll[sym];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, st) {\n    var s = st.z || dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var lst = st.l;\n    var pos = (st.r || 0) & 7;\n    if (lvl) {\n        if (pos)\n            w[0] = st.r >> 3;\n        var opt = deo[lvl - 1];\n        var n = opt >> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new i32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos\n        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;\n        for (; i + 2 < s; ++i) {\n            // hash value\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = i - dif + j & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one int32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        for (i = Math.max(i, wi); i < s; ++i) {\n            syms[li++] = dat[i];\n            ++lf[dat[i]];\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        if (!lst) {\n            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;\n            // shft(pos) now 1 less if pos & 7 != 0\n            pos -= 7;\n            st.h = head, st.p = prev, st.i = i, st.w = wi;\n        }\n    }\n    else {\n        for (var i = st.w || 0; i < s + lst; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e >= s) {\n                // write final block\n                w[(pos / 8) | 0] = lst;\n                e = s;\n            }\n            pos = wfblk(w, pos + 1, dat.subarray(i, e));\n        }\n        st.i = s;\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Adler32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length | 0;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a & 0xFF00) << 8 | (b & 255) << 8 | (b >> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    if (!st) {\n        st = { l: 1 };\n        if (opt.dictionary) {\n            var dict = opt.dictionary.subarray(-32768);\n            var newDat = new u8(dict.length + dat.length);\n            newDat.set(dict);\n            newDat.set(dat, dict.length);\n            dat = newDat;\n            st.w = dict.length;\n        }\n    }\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\\s+/g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return fnStr;\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k].buffer) {\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n        }\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            fnStr = wcln(fns[i], fnStr, td_1);\n        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };\n    }\n    var td = mrg({}, ch[id].e);\n    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt]; };\nvar bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zls]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get opts\nvar gopt = function (o) { return o && {\n    out: o.size && new u8(o.size),\n    dictionary: o.dictionary\n}; };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) {\n        if (ev.data.length) {\n            strm.push(ev.data[0], ev.data[1]);\n            postMessage([ev.data[0].length]);\n        }\n        else\n            strm.flush();\n    };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id, flush, ext) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else if (!Array.isArray(dat))\n            ext(dat);\n        else if (dat.length == 1) {\n            strm.queuedSize -= dat[0];\n            if (strm.ondrain)\n                strm.ondrain(dat[0]);\n        }\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.queuedSize = 0;\n    strm.push = function (d, f) {\n        if (!strm.ondata)\n            err(5);\n        if (t)\n            strm.ondata(err(4, 0, 1), null, !!f);\n        strm.queuedSize += d.length;\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n    if (flush) {\n        strm.flush = function () { w.postMessage([]); };\n    }\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        err(6, 'invalid gzip data');\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (o.dictionary && 32);\n    c[1] |= 31 - ((c[0] << 8) | c[1]) % 31;\n    if (o.dictionary) {\n        var h = adler();\n        h.p(o.dictionary);\n        wbytes(c, 2, h.d());\n    }\n};\n// zlib start\nvar zls = function (d, dict) {\n    if ((d[0] & 15) != 8 || (d[0] >> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        err(6, 'invalid zlib data');\n    if ((d[1] >> 5 & 1) == +!dict)\n        err(6, 'invalid zlib data: ' + (d[1] & 32 ? 'need' : 'unexpected') + ' dictionary');\n    return (d[1] >> 3 & 4) + 2;\n};\nfunction StrmOpt(opts, cb) {\n    if (typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n        this.s = { l: 0, i: 32768, w: 32768, z: 32768 };\n        // Buffer length must always be 0 mod 32768 for index calculations to be correct when modifying head and prev\n        // 98304 = 32768 (lookback) + 65536 (common chunk size)\n        this.b = new u8(98304);\n        if (this.o.dictionary) {\n            var dict = this.o.dictionary.subarray(-32768);\n            this.b.set(dict, 32768 - dict.length);\n            this.s.i = 32768 - dict.length;\n        }\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, this.s), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        var endLen = chunk.length + this.s.z;\n        if (endLen > this.b.length) {\n            if (endLen > 2 * this.b.length - 32768) {\n                var newBuf = new u8(endLen & -32768);\n                newBuf.set(this.b.subarray(0, this.s.z));\n                this.b = newBuf;\n            }\n            var split = this.b.length - this.s.z;\n            this.b.set(chunk.subarray(0, split), this.s.z);\n            this.s.z = this.b.length;\n            this.p(this.b, false);\n            this.b.set(this.b.subarray(-32768));\n            this.b.set(chunk.subarray(split), 32768);\n            this.s.z = chunk.length - split + 32768;\n            this.s.i = 32766, this.s.w = 32768;\n        }\n        else {\n            this.b.set(chunk, this.s.z);\n            this.s.z += chunk.length;\n        }\n        this.s.l = final & 1;\n        if (this.s.z > this.s.w + 8191 || final) {\n            this.p(this.b, final || false);\n            this.s.w = this.s.i, this.s.i -= 2;\n        }\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * deflated output for small inputs.\n     */\n    Deflate.prototype.flush = function () {\n        if (!this.ondata)\n            err(5);\n        if (this.s.l)\n            err(4);\n        this.p(this.b, false);\n        this.s.w = this.s.i, this.s.i -= 2;\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6, 1);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    function Inflate(opts, cb) {\n        // no StrmOpt here to avoid adding to workerizer\n        if (typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n        this.s = { i: 0, b: dict ? dict.length : 0 };\n        this.o = new u8(32768);\n        this.p = new u8(0);\n        if (dict)\n            this.o.set(dict);\n    }\n    Inflate.prototype.e = function (c) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        if (!this.p.length)\n            this.p = c;\n        else if (c.length) {\n            var n = new u8(this.p.length + c.length);\n            n.set(this.p), n.set(c, this.p.length), this.p = n;\n        }\n    };\n    Inflate.prototype.c = function (final) {\n        this.s.i = +(this.d = final || false);\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.s, this.o);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    function AsyncInflate(opts, cb) {\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Inflate(ev.data);\n            onmessage = astrm(strm);\n        }, 7, 0);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gopt(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, opts) {\n    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        this.l += chunk.length;\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, this.s);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * GZIPped output for small inputs.\n     */\n    Gzip.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8, 1);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming single or multi-member GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    function Gunzip(opts, cb) {\n        this.v = 1;\n        this.r = 0;\n        Inflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        this.r += chunk.length;\n        if (this.v) {\n            var p = this.p.subarray(this.v - 1);\n            var s = p.length > 3 ? gzs(p) : 4;\n            if (s > p.length) {\n                if (!final)\n                    return;\n            }\n            else if (this.v > 1 && this.onmember) {\n                this.onmember(this.r - p.length);\n            }\n            this.p = p.subarray(s), this.v = 0;\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n        // process concatenated GZIP\n        if (this.s.f && !this.s.l && !final) {\n            this.v = shft(this.s.p) + 9;\n            this.s = { i: 0 };\n            this.o = new u8(0);\n            this.push(new u8(0), final);\n        }\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming single or multi-member GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    function AsyncGunzip(opts, cb) {\n        var _this = this;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Gunzip(ev.data);\n            strm.onmember = function (offset) { return postMessage(offset); };\n            onmessage = astrm(strm);\n        }, 9, 0, function (offset) { return _this.onmember && _this.onmember(offset); });\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0], ev.data[1])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, opts) {\n    var st = gzs(data);\n    if (st + 8 > data.length)\n        err(6, 'invalid gzip data');\n    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        this.c.p(chunk);\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f && 4, this.s);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    /**\n     * Flushes buffered uncompressed data. Useful to immediately retrieve the\n     * zlibbed output for small inputs.\n     */\n    Zlib.prototype.flush = function () {\n        Deflate.prototype.flush.call(this);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10, 1);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, opts.dictionary ? 6 : 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    function Unzlib(opts, cb) {\n        Inflate.call(this, opts, cb);\n        this.v = opts && opts.dictionary ? 2 : 1;\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 6 && !final)\n                return;\n            this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                err(6, 'invalid zlib data');\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    function AsyncUnzlib(opts, cb) {\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, StrmOpt.call(this, opts, cb), function (ev) {\n            var strm = new Unzlib(ev.data);\n            onmessage = astrm(strm);\n        }, 11, 0);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gopt(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, opts) {\n    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    function Decompress(opts, cb) {\n        this.o = StrmOpt.call(this, opts, cb) || {};\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n    }\n    // init substream\n    // overriden by AsyncDecompress\n    Decompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (dat, final) {\n            _this.ondata(dat, final);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(this.o)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(this.o)\n                        : new this.Z(this.o);\n                this.i();\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    function AsyncDecompress(opts, cb) {\n        Decompress.call(this, opts, cb);\n        this.queuedSize = 0;\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n    }\n    AsyncDecompress.prototype.i = function () {\n        var _this = this;\n        this.s.ondata = function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        };\n        this.s.ondrain = function (size) {\n            _this.queuedSize -= size;\n            if (_this.ondrain)\n                _this.ondrain(size);\n        };\n    };\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        this.queuedSize += chunk.length;\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param opts The decompression options\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, opts) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, opts)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, opts)\n            : unzlibSync(data, opts);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k, op = o;\n        if (Array.isArray(val))\n            op = mrg(o, val[1]), val = val[0];\n        if (val instanceof u8)\n            t[n] = [val, op];\n        else {\n            t[n += '/'] = [new u8(0), op];\n            fltn(val, n, t, o);\n        }\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return { s: r, r: slc(d, i - 1) };\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    err(8);\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            err(4);\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (final) {\n            if (r.length)\n                err(8);\n            this.p = null;\n        }\n        else\n            this.p = r;\n        this.ondata(s, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        if (this.d)\n            err(4);\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td) {\n        return td.decode(dat);\n    }\n    else {\n        var _a = dutf8(dat), s = _a.s, r = _a.r;\n        if (r.length)\n            err(8);\n        return s;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                err(9);\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c < 0 && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        err(10);\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >> 1)), b += 4;\n    if (c != -1) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c < 0 ? -c - 2 : c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            err(5);\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this = this;\n        if (!this.ondata)\n            err(5);\n        // finishing or finished\n        if (this.d & 2)\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);\n        else {\n            var f = strToU8(file.filename), fl_1 = f.length;\n            var com = file.comment, o = com && strToU8(com);\n            var u = fl_1 != file.filename.length || (o && (com.length != o.length));\n            var hl_1 = fl_1 + exfl(file.extra) + 30;\n            if (fl_1 > 65535)\n                this.ondata(err(11, 0, 1), null, false);\n            var header = new u8(hl_1);\n            wzh(header, 0, file, f, u, -1);\n            var chks_1 = [header];\n            var pAll_1 = function () {\n                for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {\n                    var chk = chks_2[_i];\n                    _this.ondata(null, chk, false);\n                }\n                chks_1 = [];\n            };\n            var tr_1 = this.d;\n            this.d = 0;\n            var ind_1 = this.u.length;\n            var uf_1 = mrg(file, {\n                f: f,\n                u: u,\n                o: o,\n                t: function () {\n                    if (file.terminate)\n                        file.terminate();\n                },\n                r: function () {\n                    pAll_1();\n                    if (tr_1) {\n                        var nxt = _this.u[ind_1 + 1];\n                        if (nxt)\n                            nxt.r();\n                        else\n                            _this.d = 1;\n                    }\n                    tr_1 = 1;\n                }\n            });\n            var cl_1 = 0;\n            file.ondata = function (err, dat, final) {\n                if (err) {\n                    _this.ondata(err, dat, final);\n                    _this.terminate();\n                }\n                else {\n                    cl_1 += dat.length;\n                    chks_1.push(dat);\n                    if (final) {\n                        var dd = new u8(16);\n                        wbytes(dd, 0, 0x8074B50);\n                        wbytes(dd, 4, file.crc);\n                        wbytes(dd, 8, cl_1);\n                        wbytes(dd, 12, file.size);\n                        chks_1.push(dd);\n                        uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;\n                        if (tr_1)\n                            uf_1.r();\n                        tr_1 = 1;\n                    }\n                    else if (tr_1)\n                        pAll_1();\n                }\n            };\n            this.u.push(uf_1);\n        }\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this = this;\n        if (this.d & 2) {\n            this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);\n            return;\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this.d & 1))\n                        return;\n                    _this.u.splice(-1, 1);\n                    _this.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, -f.c - 2, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cbd(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cbd(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cbd(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl(err(11, 0, 1), null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            err(11);\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this = this;\n        this.i = new Inflate(function (dat, final) {\n            _this.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this = this;\n        if (!this.onfile)\n            err(5);\n        if (!this.p)\n            err(4);\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_3 = [];\n                        this_1.k.unshift(chks_3);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    err(5);\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this.o[cmp_1];\n                                    if (!ctr)\n                                        file_1.ondata(err(14, 'unknown compression type ' + cmp_1, 1), null, false);\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {\n                                        var dat = chks_4[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this.k[0] == chks_3 && _this.c)\n                                        _this.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                err(13);\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\nvar mt = typeof queueMicrotask == 'function' ? queueMicrotask : typeof setTimeout == 'function' ? setTimeout : function (fn) { fn(); };\nexport function unzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        err(7);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var cbd = function (a, b) {\n        mt(function () { cb(a, b); });\n    };\n    mt(function () { cbd = cb; });\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cbd(err(13, 0, 1), null);\n            return tAll;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (lft) {\n        var c = lft;\n        var o = b4(data, e + 16);\n        var z = o == 4294967295 || c == 65535;\n        if (z) {\n            var ze = b4(data, e - 12);\n            z = b4(data, ze) == 0x6064B50;\n            if (z) {\n                c = lft = b4(data, ze + 32);\n                o = b4(data, ze + 48);\n            }\n        }\n        var fltr = opts && opts.filter;\n        var _loop_3 = function (i) {\n            var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n            o = no;\n            var cbl = function (e, d) {\n                if (e) {\n                    tAll();\n                    cbd(e, null);\n                }\n                else {\n                    if (d)\n                        files[fn] = d;\n                    if (!--lft)\n                        cbd(null, files);\n                }\n            };\n            if (!fltr || fltr({\n                name: fn,\n                size: sc,\n                originalSize: su,\n                compression: c_1\n            })) {\n                if (!c_1)\n                    cbl(null, slc(data, b, b + sc));\n                else if (c_1 == 8) {\n                    var infl = data.subarray(b, b + sc);\n                    // Synchronously decompress under 512KB, or barely-compressed data\n                    if (su < 524288 || sc > 0.8 * su) {\n                        try {\n                            cbl(null, inflateSync(infl, { out: new u8(su) }));\n                        }\n                        catch (e) {\n                            cbl(e, null);\n                        }\n                    }\n                    else\n                        term.push(inflate(infl, { size: su }, cbl));\n                }\n                else\n                    cbl(err(14, 'unknown compression type ' + c_1, 1), null);\n            }\n            else\n                cbl(null, null);\n        };\n        for (var i = 0; i < c; ++i) {\n            _loop_3(i);\n        }\n    }\n    else\n        cbd(null, {});\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @param opts The ZIP extraction options\n * @returns The decompressed files\n */\nexport function unzipSync(data, opts) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            err(13);\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295 || c == 65535;\n    if (z) {\n        var ze = b4(data, e - 12);\n        z = b4(data, ze) == 0x6064B50;\n        if (z) {\n            c = b4(data, ze + 32);\n            o = b4(data, ze + 48);\n        }\n    }\n    var fltr = opts && opts.filter;\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!fltr || fltr({\n            name: fn,\n            size: sc,\n            originalSize: su,\n            compression: c_2\n        })) {\n            if (!c_2)\n                files[fn] = slc(data, b, b + sc);\n            else if (c_2 == 8)\n                files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });\n            else\n                err(14, 'unknown compression type ' + c_2);\n        }\n    }\n    return files;\n}\n", "import { gunzipSync } from 'fflate';\nimport * as db_tag from '@/services/tagService';\nimport * as db_lora from '@/services/loraService';\nimport * as db_sg from '@/services/suggestionService';\n\nexport const loadModelsData = async () => {\n    try {\n        const res = await fetch(`file=extensions/sd-webui-prompt-pilot/models.json.gz`);\n        if (!res.ok) return { success: false };\n\n        const buffer = new Uint8Array(await res.arrayBuffer());\n        const decompressedBuffer = gunzipSync(buffer);\n        const jsonString = new TextDecoder('utf-8').decode(decompressedBuffer);\n        const resData = JSON.parse(jsonString);\n\n        return { success: true, data: resData };\n    } catch (e) {\n        console.error(e);\n        return { success: false };\n    }\n};\n\nexport const initializeModels = (data: any) => {\n    db_tag.initializeTagModels(data);\n    db_lora.initializeLoraModels(data);\n    db_sg.initializeSuggestionModels(data);\n};\n", "import { useEffect } from 'preact/hooks';\nimport { loadModelsData, initializeModels } from '@/services/initializationService';\nimport { PromptPilotAction } from '@/reducers/appReducer';\nimport { Dispatch } from 'preact/hooks';\nimport { EXTENSION_ID } from '@/const/common';\n\ndeclare function onOptionsChanged(callback: VoidFunction): void;\n\nexport let resolveInitialized: ((value: boolean) => void) | null;\nconst initializedPromise = new Promise<boolean>((resolve) => {\n    resolveInitialized = resolve;\n});\n\nonOptionsChanged(() => {\n    window.pilotIsActive = window.opts[`${EXTENSION_ID}_enabled`] as boolean;\n    if (resolveInitialized) {\n        resolveInitialized(true);\n        resolveInitialized = null;\n    }\n});\n\nexport const useInitialization = (dispatch: Dispatch<PromptPilotAction>) => {\n    useEffect(() => {\n        const initialize = async () => {\n            const result = await loadModelsData();\n            if (result.success) {\n                try {\n                    await initializedPromise;\n                    initializeModels(result.data);\n                    dispatch({\n                        type: 'SET_STATUS',\n                        payload: 'success',\n                    });\n                } catch (e) {\n                    console.error(e);\n                    dispatch({\n                        type: 'SET_STATUS',\n                        payload: 'error',\n                    });\n                }\n            }\n        };\n\n        initialize();\n    }, [dispatch]);\n};\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { Fragment, h } from 'preact';\nimport { useCallback, useEffect, useRef } from 'preact/hooks';\nimport { TEXTAREA_SELECTOR } from '@/const/common';\nimport { dispatchSetTextarea } from '@/reducers/dispatchHelper';\nimport { Preview } from '@/components/ui/PreviewSection';\nimport { Items } from '@/components/ui/ListSection';\nimport { Tabs } from '@/components/ui/TabsSection';\nimport { setDisplay, setPosition } from '@/helpers/styleHelper';\nimport { usePromptPilot } from '@/components/core/App';\nimport { TextareaEventHandlers } from '@/hooks/useTextareaHandlers';\nimport { useInitialization } from '@/hooks/useInitialization';\n\nexport const UITemplateContent = () => {\n    const { state, dispatch } = usePromptPilot();\n\n    const component = useRef(null);\n\n    useInitialization(dispatch);\n\n    const handleClickAnyware = useCallback(\n        (e: MouseEvent) => {\n            const target = e.target as HTMLElement;\n            if (target.closest('#suggestion-box')) {\n                e.stopPropagation();\n                return;\n            }\n            if (target.matches(TEXTAREA_SELECTOR)) {\n                dispatchSetTextarea(dispatch, target as PilotTextArea);\n            } else {\n                dispatchSetTextarea(dispatch, null);\n            }\n            e.stopPropagation();\n        },\n        [dispatch],\n    );\n\n    useEffect(() => {\n        document.addEventListener('mousedown', handleClickAnyware);\n        return () => document.removeEventListener('mousedown', handleClickAnyware);\n    }, [handleClickAnyware]);\n\n    return (\n        <>\n            <TextareaEventHandlers />\n            <div id=\"suggestion-box\" ref={component} style={{ ...setPosition(state.pos), ...setDisplay(state) }}>\n                <Tabs></Tabs>\n                <Items></Items>\n                <Preview></Preview>\n            </div>\n        </>\n    );\n};\n", "import { AppProps, ItemProps, ParseResult } from '@/types/props';\n\nexport type PromptPilotAction =\n    | { type: 'SET_TEXTAREA'; payload: PilotTextArea | null }\n    | { type: 'SET_VISIBILITY'; payload: boolean }\n    | {\n          type: 'SET_STATUS';\n          payload: 'loading' | 'error' | 'success';\n      }\n    | {\n          type: 'SET_POSITION';\n          payload: {\n              x: number;\n              y: number;\n              offset_x: number;\n              offset_y: number;\n          };\n      }\n    | { type: 'SET_TAB'; payload: string }\n    | { type: 'SET_SELECTED_ITEM'; payload: ItemProps }\n    | {\n          type: 'SET_ITEMS';\n          payload: {\n              type: 'tag' | 'lora' | 'simple';\n              items: ItemProps[];\n          };\n      }\n    | {\n          type: 'SET_MESSAGE';\n          payload: {\n              type: 'tag' | 'lora' | 'simple';\n              message: string;\n          };\n      }\n    | {\n          type: 'SET_PARSE_RESULT';\n          payload: ParseResult;\n      };\n\nexport const promptPilotReducer = (state: AppProps, action: PromptPilotAction): AppProps => {\n    if (action.type === 'SET_TEXTAREA') {\n        return {\n            ...state,\n            isVisible: false,\n            textarea: action.payload,\n            selectedCategory: 'all',\n        };\n    } else if (action.type === 'SET_VISIBILITY') {\n        return {\n            ...state,\n            isVisible: action.payload,\n            selectedCategory: 'all',\n        };\n    } else if (action.type === 'SET_STATUS') {\n        return {\n            ...state,\n            status: action.payload,\n        };\n    } else if (action.type === 'SET_POSITION') {\n        return {\n            ...state,\n            pos: {\n                offset_x: action.payload.offset_x,\n                offset_y: action.payload.offset_y,\n                x: action.payload.x,\n                y: action.payload.y,\n            },\n        };\n    } else if (action.type === 'SET_TAB') {\n        return {\n            ...state,\n            selectedCategory: action.payload,\n        };\n    } else if (action.type === 'SET_SELECTED_ITEM') {\n        return {\n            ...state,\n            selectedItem: action.payload,\n        };\n    } else if (action.type === 'SET_ITEMS') {\n        return {\n            ...state,\n            isVisible: true,\n            type: action.payload.type,\n            items: action.payload.items,\n            selectedItem: action.payload.items.length > 0 ? action.payload.items[0] : null,\n            message: action.payload.items.length > 0 ? '' : 'No results found',\n        };\n    } else if (action.type === 'SET_MESSAGE') {\n        return {\n            ...state,\n            isVisible: true,\n            type: action.payload.type,\n            message: action.payload.message,\n        };\n    } else if (action.type === 'SET_PARSE_RESULT') {\n        return {\n            ...state,\n            parseResult: action.payload,\n        };\n    } else {\n        return state;\n    }\n};\n", "import { createContext, FunctionComponent, h, render } from 'preact';\nimport { Dispatch, useContext, useReducer } from 'preact/hooks';\nimport { AppProps } from '@/types/props';\nimport { UITemplateContent } from '@/components/ui/AppComponent';\nimport { PromptPilotAction, promptPilotReducer } from '@/reducers/appReducer';\n\nconst PromptPilotContext = createContext<{\n    state: AppProps;\n    dispatch: Dispatch<PromptPilotAction>;\n} | null>(null);\n\nexport const usePromptPilot = () => {\n    const context = useContext(PromptPilotContext);\n    if (!context) {\n        throw new Error('usePromptPilot must be used within a PromptPilotProvider');\n    }\n    return context;\n};\n\nexport const PromptPilotProvider: FunctionComponent<{\n    promptPilotState: AppProps;\n    children: h.JSX.Element | h.JSX.Element[];\n}> = ({ promptPilotState, children }) => {\n    const [state, dispatch] = useReducer(promptPilotReducer, promptPilotState);\n\n    return <PromptPilotContext.Provider value={{ state, dispatch }}>{children}</PromptPilotContext.Provider>;\n};\n\nexport function initialize(promptPilotProps: AppProps): void {\n    render(\n        <PromptPilotProvider promptPilotState={promptPilotProps}>\n            <UITemplateContent />\n        </PromptPilotProvider>,\n        document.getElementById('prompt-pilot-container')!,\n    );\n}\n", "import * as db_lora from '@/services/loraService';\nimport { API_PREFIX, TEXTAREA_SELECTOR } from '@/const/common';\nimport { ResponseData } from '@/types/api';\nimport { initialize } from '@/components/core/App';\n\ndeclare function gradioApp(): HTMLElement;\ndeclare function onUiLoaded(callback: VoidFunction): void;\n\nwindow.pilotIsActive = true;\n\nonUiLoaded(() => {\n    const promptTextareas = gradioApp().querySelectorAll<HTMLTextAreaElement>(TEXTAREA_SELECTOR);\n    const computedStyle = getComputedStyle(promptTextareas[0]);\n    let cssStyleString = '';\n    const ignoredCssProperties = new Set<string>(['width', 'height', 'inline-size', 'block-size', 'resize']);\n    for (let i = 0; i < computedStyle.length; i++) {\n        const prop = computedStyle[i];\n        if (!ignoredCssProperties.has(prop)) {\n            const value = computedStyle.getPropertyValue(prop);\n            cssStyleString += `${prop}: ${value};`;\n        }\n    }\n\n    promptTextareas.forEach((_textarea) => {\n        const textarea = _textarea as PilotTextArea;\n        const dummyDiv = document.createElement('div') as HTMLDivElement & { caret: HTMLSpanElement };\n        dummyDiv.className = 'prompt_pilot-dummy';\n        textarea.parentNode?.insertBefore(dummyDiv, textarea.nextSibling);\n        textarea.dummy = dummyDiv;\n\n        const caretSpan = document.createElement('span');\n        dummyDiv.caret = caretSpan;\n    });\n\n    const cssStyleSheet = new CSSStyleSheet();\n    cssStyleSheet.replaceSync(`.prompt_pilot-dummy {${cssStyleString}}`);\n    document.adoptedStyleSheets = [...document.adoptedStyleSheets, cssStyleSheet];\n\n    const promptPilotContainer = document.createElement('div');\n    promptPilotContainer.id = 'prompt-pilot-container';\n    gradioApp().appendChild(promptPilotContainer);\n\n    initialize({\n        isVisible: false,\n        status: 'loading',\n        type: 'tag',\n        textarea: null,\n        selectedCategory: 'all',\n        selectedItem: null,\n        items: [],\n        pos: {\n            offset_x: 0,\n            offset_y: 0,\n            x: 0,\n            y: 0,\n        },\n        parseResult: {\n            promptInfo: {\n                prompt: '',\n                caretPosition: 0,\n                inputtingString: '',\n                activeWordIndex: -1,\n                words: [],\n            },\n            insertionInfo: {\n                isMetaBlock: false,\n                needPrependComma: false,\n                needPrependSpace: false,\n            },\n        },\n        message: '',\n    });\n\n    const refreshButtonSelector = '.extra-network-control--refresh';\n    const refreshButtons = gradioApp().querySelectorAll<HTMLDivElement>(refreshButtonSelector);\n    refreshButtons.forEach((button) => {\n        button.addEventListener('click', () => {\n            fetch(`${API_PREFIX}/refresh`, { method: 'POST' }).then(async (res) => {\n                const resData: ResponseData | undefined = await res.json();\n                db_lora.initializeLoraModels(resData);\n            });\n        });\n    });\n});\n"],
  "mappings": "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",
  "names": ["require_classnames", "__commonJSMin", "exports", "module", "hasOwn", "classNames", "classes", "arg", "appendClass", "parseValue", "key", "value", "newClass", "EXTENSION_ID", "API_PREFIX", "TEXTAREA_SELECTOR", "DEBOUNCE_DELAY", "loraModels", "initializeLoraModels", "resData", "lora_name", "data", "searchLora", "query", "queries", "q", "resultSet", "lora", "matchWordSet", "word", "flatWord", "props", "w", "a", "b", "compare", "groupCounter", "EXTENSION_ID", "self", "other", "thisStartsQuery", "matchStarts", "otherStartsQuery", "obj", "title", "slice", "options", "vnodeId", "isValidElement", "rerenderQueue", "prevDebounce", "defer", "depthSort", "CAPTURE_REGEX", "eventClock", "eventProxy", "eventProxyCapture", "i", "EMPTY_OBJ", "EMPTY_ARR", "IS_NON_DIMENSIONAL", "isArray", "Array", "assign", "obj", "props", "removeNode", "node", "parentNode", "removeChild", "createElement", "type", "children", "key", "ref", "normalizedProps", "arguments", "length", "call", "defaultProps", "undefined", "createVNode", "original", "vnode", "__k", "__", "__b", "__e", "__c", "constructor", "__v", "__i", "__u", "Fragment", "props", "children", "BaseComponent", "context", "this", "getDomSibling", "vnode", "childIndex", "__", "__i", "sibling", "__k", "length", "__e", "type", "updateParentDomPointers", "i", "child", "__c", "base", "enqueueRender", "c", "__d", "rerenderQueue", "push", "process", "__r", "prevDebounce", "options", "debounceRendering", "defer", "component", "newVNode", "oldVNode", "oldDom", "commitQueue", "refQueue", "l", "sort", "depthSort", "shift", "__v", "__P", "assign", "diff", "__n", "namespaceURI", "__u", "commitRoot", "diffChildren", "parentDom", "renderResult", "newParentVNode", "oldParentVNode", "globalContext", "namespace", "excessDomChildren", "isHydrating", "childVNode", "newDom", "firstChildDom", "result", "oldChildren", "EMPTY_ARR", "newChildrenLength", "constructNewChildrenArray", "EMPTY_OBJ", "ref", "applyRef", "insert", "nextSibling", "skewedIndex", "matchingIndex", "oldChildrenLength", "remainingOldChildren", "skew", "Array", "constructor", "String", "createVNode", "isArray", "undefined", "__b", "key", "findMatchingIndex", "unmount", "parentVNode", "contains", "insertBefore", "nodeType", "findMatchingIndex", "childVNode", "oldChildren", "skewedIndex", "remainingOldChildren", "x", "y", "key", "type", "oldVNode", "__u", "length", "setStyle", "style", "value", "setProperty", "IS_NON_DIMENSIONAL", "test", "dom", "name", "oldValue", "namespace", "useCapture", "o", "cssText", "replace", "CAPTURE_REGEX", "toLowerCase", "slice", "l", "_attached", "eventClock", "addEventListener", "eventProxyCapture", "eventProxy", "removeEventListener", "e", "removeAttribute", "setAttribute", "createEventProxy", "this", "eventHandler", "_dispatched", "options", "event", "diff", "parentDom", "newVNode", "globalContext", "excessDomChildren", "commitQueue", "oldDom", "isHydrating", "refQueue", "tmp", "c", "isNew", "oldProps", "oldState", "snapshot", "clearProcessingException", "newProps", "isClassComponent", "provider", "componentContext", "i", "renderHook", "count", "renderResult", "newType", "constructor", "undefined", "__e", "__b", "outer", "props", "prototype", "render", "contextType", "__c", "__", "__E", "BaseComponent", "doRender", "sub", "state", "context", "__n", "__d", "__h", "_sb", "__s", "getDerivedStateFromProps", "assign", "__v", "componentWillMount", "componentDidMount", "push", "componentWillReceiveProps", "shouldComponentUpdate", "__k", "some", "vnode", "componentWillUpdate", "componentDidUpdate", "__P", "__r", "getChildContext", "getSnapshotBeforeUpdate", "Fragment", "cloneNode", "children", "diffChildren", "isArray", "base", "then", "MODE_HYDRATE", "nodeType", "nextSibling", "indexOf", "removeNode", "diffElementNodes", "diffed", "commitRoot", "root", "applyRef", "cb", "call", "node", "map", "newHtml", "oldHtml", "newChildren", "inputValue", "checked", "localName", "document", "createTextNode", "createElementNS", "is", "__m", "data", "childNodes", "EMPTY_OBJ", "attributes", "__html", "innerHTML", "content", "getDomSibling", "ref", "hasRefUnmount", "current", "unmount", "parentVNode", "skipRemove", "r", "componentWillUnmount", "replaceNode", "documentElement", "createElement", "namespaceURI", "firstChild", "createContext", "defaultValue", "Context", "props", "subs", "ctx", "this", "getChildContext", "Set", "__c", "componentWillUnmount", "shouldComponentUpdate", "_props", "value", "forEach", "c", "__e", "enqueueRender", "sub", "add", "old", "delete", "call", "children", "i", "__", "Provider", "__l", "Consumer", "contextValue", "contextType", "slice", "EMPTY_ARR", "options", "error", "vnode", "oldVNode", "errorInfo", "component", "ctor", "handled", "constructor", "getDerivedStateFromError", "setState", "__d", "componentDidCatch", "__E", "e", "vnodeId", "isValidElement", "undefined", "BaseComponent", "prototype", "update", "callback", "s", "__s", "state", "assign", "__v", "_sb", "push", "forceUpdate", "__h", "render", "Fragment", "rerenderQueue", "defer", "Promise", "then", "bind", "resolve", "setTimeout", "depthSort", "a", "b", "__b", "process", "__r", "CAPTURE_REGEX", "eventClock", "eventProxy", "createEventProxy", "eventProxyCapture", "currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useReducer", "reducer", "initialState", "init", "hookState", "getHookState", "currentIndex", "_reducer", "__c", "__", "invokeOrReturn", "action", "currentValue", "__N", "nextValue", "setState", "currentComponent", "__f", "updateHookState", "p", "s", "c", "__H", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "props", "forEach", "hookItem", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useEffect", "callback", "args", "state", "options", "__s", "argsChanged", "_pendingArgs", "__h", "push", "useRef", "initialValue", "currentHook", "useMemo", "current", "useMemo", "factory", "args", "state", "getHookState", "currentIndex", "argsChanged", "__H", "__", "__h", "useCallback", "callback", "currentHook", "useContext", "context", "provider", "currentComponent", "__c", "c", "sub", "props", "value", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "dispatchSetVisibility", "dispatch", "visibility", "dispatchSetPosition", "contextPosition", "dispatchSetTextarea", "textarea", "dispatchSetTab", "category", "dispatchSetItems", "type", "items", "dispatchSetSelectedItem", "item", "dispatchSetMessage", "message", "Preview", "state", "usePromptPilot", "_", "import_classnames", "debounceWithLeadingTrailing", "func", "wait", "timeout", "lastCallTime", "lastArgs", "hasPendingTrailing", "args", "now", "formatNumberWithUnits", "num", "tagModels", "tagIndex", "alwaysUnderscoreTags", "alwaysSpaceTags", "initializeTagModels", "resData", "EXTENSION_ID", "tag", "data", "splitTag", "tagModel", "alias", "splitAlias", "aliasTagModel", "buildTagIndex", "getPrefixes", "maxLen", "set", "t", "len", "prefixes", "p", "appendTagModel", "getTagModel", "searchTag", "query", "priorityTags", "queries", "q", "joinedQuery", "priorityTagSet", "resultList", "resultKeySet", "queryForCandidate", "prefixKey", "candidateTagList", "key", "matchedWords", "i", "matchedQueryIndices", "props", "consequentTagMatchCount", "r", "acc", "consequentTag", "resultTagCount", "resultCount", "m", "a", "b", "compare", "groupCounter", "self", "other", "count", "debounceSearchWithApi", "debounceWithLeadingTrailing", "callback", "apiUrl", "resultSet", "res", "item", "consequentTagModel", "err", "insertWordIntoPrompt", "state", "itemProps", "insertionData", "getTagInsertionData", "getLoraInsertionData", "getSuggestionInsertionData", "usingExecCommand", "textarea", "val", "props", "promptInfo", "insertionInfo", "startPosition", "offset", "tags", "insertionRange", "wordInfo", "splitStringWithIndices", "tag", "escapedPart", "escapeRegex", "unescapePrompt", "match", "insertTag", "source", "EXTENSION_ID", "delimiter", "alwaysSpaceTags", "replaceToUnderscore", "alwaysUnderscoreTags", "escapePrompt", "loraName", "caret", "category", "getTagModel", "word", "escapeRegex", "str", "escapePrompt", "unescapePrompt", "props", "i", "splitStringWithIndices", "input", "delimiter", "regex", "match", "lastIndex", "openWiki", "title", "domain", "EXTENSION_ID", "Items", "state", "dispatch", "usePromptPilot", "y", "selectedElement", "items", "item", "handleSelectItem", "e", "element", "dispatchSetSelectedItem", "handleApplyItem", "target", "insertWordIntoPrompt", "tag", "openWiki", "dispatchSetVisibility", "message", "_", "i", "classNames", "HighlightedText", "formatNumberWithUnits", "highlightText", "text", "result", "matchedWord", "wordIndex", "escapedWord", "escapeRegex", "regex", "newResult", "part", "partIndex", "segment", "segmentIndex", "k", "import_classnames", "Tabs", "state", "dispatch", "usePromptPilot", "handleSelectTab", "category", "dispatchSetTab", "tabDefines", "_", "classNames", "title", "isVisible", "state", "promptInfo", "insertionInfo", "EXTENSION_ID", "calcContextPosition", "textarea", "dummy", "caret", "caretIndex", "textBeforeCaret", "textAfterCaret", "rect", "computedStyle", "lineHeight", "textareaRect", "x", "y", "setPosition", "offset_x", "offset_y", "x", "y", "setDisplay", "state", "isVisible", "openerToType", "closerToType", "closerForType", "delimiters", "delimitersWithoutComma", "PREFIX_LENGTH", "metaKeywords", "dynamicPromptRegex", "matchMetaKeywordRegex", "makeWordData", "nestType", "position", "updatePromptState", "prompt", "caret", "promptInfo", "insertionInfo", "match", "_", "group1", "group2", "nestTypes", "isEscaped", "delimiter", "isNewLine", "flush", "word", "updateContextState", "char", "updatePrependFlags", "setActiveWordData", "inputtingString", "i", "currentNestType", "openerType", "loraPrefix", "expectedCloser", "colonIndex", "wordValue", "weightValue", "isNumber", "loraName", "multiplier", "value", "useTextareaEvent", "eventName", "handler", "deps", "state", "usePromptPilot", "y", "typedHandler", "useMouseEvent", "useKeyboardEvent", "useCompositionEvent", "suggestionModels", "initializeSuggestionModels", "resData", "word", "record", "sorted", "count1", "count2", "count", "searchSuggestion", "nearestTag", "existTags", "suggestions", "props", "candidate", "extractPromptInfo", "state", "textarea", "updatePromptState", "collectExistingTags", "promptInfo", "word", "i", "findNearestTag", "collectPriorityTags", "inputtingString", "nearestTag", "existTags", "suggestions", "searchSuggestion", "priorityTag", "suggestion", "handleTagItems", "dispatch", "dispatchSetItems", "debounceSearchWithApi", "resultSet", "dispatchSetMessage", "items", "searchTag", "handleLoraItems", "searchLora", "updateContext", "parseResult", "activeWord", "debounceUpdateContext", "debounceWithLeadingTrailing", "updateContext", "DEBOUNCE_DELAY", "processingPromise", "TextareaEventHandlers", "state", "dispatch", "usePromptPilot", "isWeightMode", "A", "isComposingRef", "useMouseEvent", "e", "resolve", "textarea", "parseResult", "updatePromptState", "promptInfo", "activeWord", "word", "openWiki", "useCompositionEvent", "dispatchSetPosition", "calcContextPosition", "useKeyboardEvent", "key", "dispatchSetVisibility", "itemProps", "insertWordIntoPrompt", "tagResult", "tag", "direction", "filteredItems", "item", "currentIndex", "nextIndex", "dispatchSetSelectedItem", "u8", "u16", "i32", "fleb", "fdeb", "clim", "freb", "eb", "start", "b", "i", "r", "j", "_a", "fl", "revfl", "_b", "fd", "revfd", "rev", "x", "hMap", "cd", "mb", "s", "l", "le", "co", "rvb", "sv", "r_1", "v", "m", "flt", "fdt", "flrm", "hMap", "flt", "fdrm", "hMap", "fdt", "max", "a", "m", "i", "bits", "d", "p", "o", "bits16", "shft", "slc", "v", "s", "e", "u8", "ec", "err", "ind", "msg", "nt", "e", "inflt", "dat", "st", "buf", "dict", "sl", "dl", "u8", "noBuf", "resize", "noSt", "cbuf", "l", "bl", "nbuf", "final", "pos", "bt", "lm", "dm", "lbt", "dbt", "tbts", "bits", "type", "flrm", "fdrm", "hLit", "hcLen", "tl", "ldt", "clt", "i", "clim", "clb", "max", "clbmsk", "clm", "hMap", "r", "s", "c", "n", "dt", "shft", "t", "lms", "dms", "lpos", "bits16", "sym", "add", "b", "fleb", "fl", "d", "dsym", "fd", "fdeb", "end", "shift", "dend", "slc", "et", "u8", "gzs", "d", "err", "flg", "st", "zs", "gzl", "l", "gunzipSync", "data", "opts", "st", "gzs", "err", "inflt", "u8", "gzl", "td", "tds", "et", "loadModelsData", "res", "buffer", "decompressedBuffer", "gunzipSync", "jsonString", "initializeModels", "data", "initializeTagModels", "initializeLoraModels", "initializeSuggestionModels", "resolveInitialized", "initializedPromise", "resolve", "EXTENSION_ID", "useInitialization", "dispatch", "y", "result", "loadModelsData", "initializeModels", "e", "UITemplateContent", "state", "dispatch", "usePromptPilot", "component", "A", "useInitialization", "handleClickAnyware", "q", "e", "target", "TEXTAREA_SELECTOR", "dispatchSetTextarea", "y", "_", "k", "TextareaEventHandlers", "setPosition", "setDisplay", "Tabs", "Items", "Preview", "promptPilotReducer", "state", "action", "PromptPilotContext", "K", "usePromptPilot", "context", "x", "PromptPilotProvider", "promptPilotState", "children", "state", "dispatch", "h", "promptPilotReducer", "_", "initialize", "promptPilotProps", "E", "UITemplateContent", "promptTextareas", "TEXTAREA_SELECTOR", "computedStyle", "cssStyleString", "ignoredCssProperties", "i", "prop", "value", "_textarea", "textarea", "dummyDiv", "caretSpan", "cssStyleSheet", "promptPilotContainer", "initialize", "button", "API_PREFIX", "res", "resData", "initializeLoraModels"]
}
